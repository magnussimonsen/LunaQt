// * Introduction

// This file contains the documentation for the functions, the
// operators and the syntax elements, which are built into the C/C++
// source code of Euler Math Toolbox (EMT). The file does also contain
// technical documentation for some built-in features of EMT. The
// documentation of EMT refers to these core features whenever
// necessary. This page is a HTML version of "help.txt".

// Do not use this as the starting point to learn EMT. For that,
// have a look at the introduction notebooks.

// There are many functions in other packages, replacing the built-in
// functions of this file, or adding additional features. Follow the
// links provided in this document.

// Many built-in functions have "comment" functions in the utility
// files. This helps to keep groups of related functions in one place.
// The utility functions are documented in separate HTML pages,
// which are generated from the utility files.

// * Help in EMT

// To open the context sensitive help in EMT press F1 or double
// click on an item in the notebook. The help window will open and can
// be used to search for keywords or to follow the links. It
// can also open the HTML documentation. 

// Another way to get help is to use the HTML documentation in form of
// introduction notebooks and examples or the HTML reference. 

// Also observe the status line in the notebook window for information
// on the current command or option.

!help,mxmhelp,helpwindow

To find help on a specific function, you can

 - Look at the status line, while you type.
 - Press F1, open the help window, and enter the function name.
 - Open the complete reference in the browser.

There are some commands in the notebook window, which print help
directly to the notebook window.

  help topic : Displays help for a user function, a built-in function
    and other Euler commands, programming keywords and
    other items.

  mxmhelp topic: Display help for a Maxima command.

See: Help, Keyboard
#

!quit

quit: This command quits Euler immediately.
#

// * Operators and Functions

// Euler uses the well known mathematical operators and functions.
// For operators, take care of precedence, or set round brackets in
// case of doubt (e.g. for ^ which is treated differently in
// different packages). Another point to keep in mind is that
// trigonometric functions work in radians, not in degrees. To convert
// degrees to radians append ° or use the function rad() and
// conversely deg().

// To get an introduction into the syntax of EMT, look at the
// following notebooks.

// See: ../Programs/00 - A first Welcome | A first Welcome
// See: ../Programs/00 - A Crash Course in Euler | Crash Course
// See: ../Programs/00 - The Syntax of Euler | The Syntax of EMT

// See: functions.html | Special Functions

!+,-,*,^,/

The usual arithmetic operations. Note that these operators, as well as
most functions in Euler, obey the Euler matrix language. I.e., they
work element-wise for matrices. The matrix product is denoted by a
simple dot ".". Note that ^ in Euler uses left binding, so a^b^c is
equal to (a^b)^c.

See: .
See: matrixlanguage

Division and powers generate runtime errors, if they are not defined
for the arguments. This can be prevented by "errors off". Then NaN
(not a number) is returned.

The underflows that ^ produces are caught to 0, if underflows is off
(the default). 

  >2*(3+4)^2
  >2^2^3-2^8
  >(2^2)^3-4^3
  >(1e-200)^2
  >errors off; 1/0; errors on;

  >A=[1,2;4,5]; A.A

  >"A"+"B"
   AB


The operator "+" does also concatenate strings.

See: underflows
#

!abs,exp,log,sign,sqrt

The most frequent usual mathematical functions. They work for real,
complex and intervals scalars, vectors and matrices. The functions
work element-wise for matrices, and obey to the rules of the Euler
matrix language.

  abs(x) : absolute value
  exp(x) : exponential function
  log(x) : natural logarithm, main branch for complex
  sign(x) : sign of reals
  sqrt(x) : square root function, with main branch for complex values

To compute the exponential etc. for a matrix, use "matrixfunction".

The underflows that exp produces are caught to 0, if underflows is off
(the default). This can be changed with "errors off" and "errors on". 

  >log(E)
  >abs(1+I);
  >sqrt(complex(-1))^2
  >plot2d("sign",-1,1);

See: log10, logbase, sin
#

!sin,cos,tan,asin,acos,atan,arctan2,atan2,arcsin,arccos,arctan

The usual trigonometric mathematical functions, for real, complex and
intervals.

  sin(x) : sine function
  cos(x) : cosine function
  tan(x) : tangent function
  asin(x) : inverse sine, maps [-1,1] to [-pi/2,pi/2]
  acos(x) : inverse cosine, maps [-1,1] to [0,pi]
  atan(x) : inverse tangent, maps R to [-pi/2,pi/2]
  arcsin(x) : inverse sine, maps [-1,1] to [-pi/2,pi/2]
  arccos(x) : inverse cosine, maps [-1,1] to [0,pi]
  arctan(x) : inverse tangent, maps R to [-pi/2,pi/2]
  arctan2(x,y) : Angle of the polar coordinates of [x,y] in ]-pi,pi].
  atan2(x,y) : Angle of the polar coordinates of [x,y] in ]-pi,pi].

The functions work for radians. To convert from degree to radians use
x° or rad(x). Use shift-F7 to enter the degree symbol in an Euler
notebook. To convert back, use deg().

The degree symbol ° works in Maxima too.

  >sin(90°)
  >cos(pi)
  >deg(atan(1))
  >deg(atan2(1,1))
  >degprint(rad(10,30,20))

See: polar, rect, matrixlanguage, deg, rad, degprint
#

!bin,fac,!,logbin,logfac

Maxima can compute "infinite" versions of n! and bin(n,m). For the
numerical version consider logbin() and logfac() to avoid overflows.
The binomial coefficient works for real x.

  bin(x,m) : Binomial coefficient.

  logbin(n,m) : Logarithm of the bin(n,m).
    This is useful for large n, m.

  fac(n), n! : Factorial function of n.

  logfac(n) : Logarithm of the factorial function
    Useful for large n.

  >bin(10,0:10)
  >bin(49,6)-49!/(6!*43!)
  >logfac(100)-sum(log(2:100))

See: binsum, invbinsum, gamma
#

!ceil,floor,round,mod

Note that EMT has only a double arithmetic. Integer values work up to
about 15 digits. Maxima has an "infinite" integer arithmetic.

  ceil(x) : The smallest integer above x.
  floor(x) : The largest integer below x.

  round(x,[n]) : x rounded to n digits.
    Default is n=0.

  mod(x,y) : x modulo y.
    This works for non-integer y too.

  >x-floor(x)
  >floor(1.9)
  >round(1.9)
  >round(-1.9)

See: print, frac
#

!complex,re,im,arg,conj,real

EMT tries to keep results real as long as possible.

  re(x) : The real part of x.
  im(x) : The imaginary part of x.
  complex(x) : Makes the real argument x complex.
  conj(x) : Conjugate of the complex value x.
  arg(x) : The argument of the complex value x.
  
  real(x) : makes x real.
    If the imaginary part of x is too large, an error will be
    issued.

  >sqrt(-1) // Error!
  >sqrt(complex(-1))
  >A=random(10,10); sort(real(eigenvalues(A.A')))
  >deg(arg(I)) // 90

See: carg, conjugate
#

!I,E,Pi,pi,%e,%pi

For the seamless integration of Maxima, EMT supports %e and %pi. 

  I : The imaginary unit (also %i and 1i)
  E : exp(1) (also %e)
  Pi : pi() (also pi, %pi)

Do not use e for E. 

#

!true,false

EMT has boolean operators. Moreover, many functions require true/false
switches. Thus these constants are represented by 1 and 0. For
function parameters, e.g. ">add" is the same as "add=true", and "<add"
is the same as "add=false".

  true: The constant 1.
  false: the constant 0.

All boolean functions and operators return 1 or 0.

#

!<,>,<=,>=,<>,==,~=

Comparison operators, returning 0 or 1. 0 means false, and 1 means
true. These operators obey to the rules of the Euler matrix language.
To assert that the result is true for any or all elements of a matrix,
use any(v) or all(v).

Note that "==" must be used to test for equality.

a~=b compares for equality taking into account the internal epsilon.
This operator works for intervals too.

Note that that conditions in "if" do not allow boolean vectors. Thus
any(v) or all(v) must be used to check vectors.

  >sum(0.1*ones(1,10))==1 // inevitably false
  >sum(0.1*ones(1,10))~=1 // true
  >(pi>3)&&(pi<4) // true
  >if any(random(100)>0.99) then "found", else "no", endif

See: <<, matrixlanguage, any, all, epsilon
#

!&&,||,!

  a&&b : returns a and-connected with b in case of reals. 
    I.e., the result will be 1, if both a and b are non-zeros.
  
  I&&J : The interval intersection of I and J.
  
  a||b : returns a or-connected with b in case of reals. 
    I.e., the result will be 1, if both a and b are non-zeros.
  
  I||J : The interval union of I and J.

  !a : return 0 if a is non-zero, or 1, if a is zero.

These operators work for matrix input like all operators in Euler.
They produce a matrix of 1 or 0 in this case.

See: and, or, not, if, bitand, bitor, bitxand, bitnot
#

!and,or,not

  and,or : Shortcut logical operators. 

This can only be used in conditional clauses for "if", "while" or
"until".

Only the necessary parts of the conditions are evaluated. "and" binds
stronger than "or". But it might be more clear to use round brackets.

  not : Binds stronger than "and" or "or".

These operators accept only reals. They are good for if-conditions or
while- and until-statements. For logical operations, use "&&", "||",
"!".

  >v=random(1,10);
  >i=12; if i<=cols(v) && v[i]>0.5 then "yes", else "no" endif;
   Index 12 out of bounds! 
   ...
  >i=12; if i<=cols(v) and v[i]>0.5 then "yes", else "no" endif;
   no

See: ||, &&, !, bitand, bitor, bitxor, bitnot
#

!iscomplex,isfunction,isinterval,isreal,typeof,printtype,issymbolic,isempty

  isreal(x) : tests, if x is real.
  iscomplex(x) : tests, if x is complex.
  isinterval(x) : tests, if x is an interval scalar or matrix.
  isfunction(x) : tests, if x is a function.
  isstring(x) : tests, if x is a string.
  issymbolic(x) : tests, if x is a symbolic expression.
  isempty(x) : tests, if x is none or an empty vector.

  typeof(var) : The type of the expression.

The types are: 0=real, 1=complex, 2=matrix, 3=comples matrix,
4=reference, 5=command, 6=submatrix, 7=complex submatrix, 8=string,
9=function, 10=interval, 11=interval matrix, 12=interval submatrix,
13=string matrix, 14=compresses sparse matrix, 15=binary data,
16=collection

  printtype(x) : String containing the type of x.

#

!bitand,bitor,bitxor,bitnot

Connect two integer values bit by bit. The double values are converted
to 32 bit integers first.

  bitand(x,y) : bitwise and
  bitor(x,y) : bitwise or
  bitxor(x,y) : bitwise exclusive or
  bitnot(x,y) : bitwise not

See: &&, ||, !
#

!=,:=,::=,assignment

  variable = value : Assigns the value to the variable.
    The variable may be a variable name or a
    submatrix of a matrix.

  variable := value : More strict form of the assignment. Recommended.
  variable ::= value : Sets a numerical variable in Euler and in Maxima.

For symbolical variables use "&=".

See: submatrix, multiple, &=, &:=
#

!submatrix,[,]

  [...] : Defines a matrix row by row. The columns must be separated
    by commas, the rows by semicolons. In compatibility mode of
    Maxima, this works for symbolic matrices too. [] is an empty 0x0
    matrix. It can be used to attach rows or columns to it.

  ["string",...] : Defines a string vector. 
    [none] is the empty string vector. It can be used
    to append strings or string vectors to it.

  A[i,j] : Defines a single element of a matrix or a submatrix
    If an index in i or j is out of range, it is neglected, or
    there will be an error message (the default). Negative
    indices count from the end. If i and j are vectors of
    indices, the submatrix with rows in i, and columns in j is
    used.

Note that matrix indices start with 1 in Euler. -1 is the last element
of the matrix.

  A[i] : The i-th element of a vector, or the i-th row of a matrix 
    with more than one row. A[-1] is the last element (resp.
    row). Note that A[i] returns different things if, A is a 1xm
    or a nxm (n>1) matrix. To make sure to get the i-th row, use
    A[i,].

  s[i] : The i-th element of the string vector s, or a string vector
    with the indices from the row vector i.

  A[:,j] : Denotes all rows here. This is the j-th column of A, or
    the columns with indices in the row vector j.

  A[,j] : Short form for A[:,j].

  A[i,:] : The i-th row of A
    or the rows with indices in the row vector i.

  A[i,] : Short form of A[i,:].

See: =,{
#

!(,)

Round brackets are used to group operations as in (3+4)*5, to call
functions as in sin(pi), or to evaluate expression.

When "expr" is a string expression, expr(...) evaluates it in Euler. 
The parameters are automatically assigned to x, y, z. Other parameters
may be added as assigned parameters as in expr(2,a=1). The evaluation
sees global variables too, and local variables in the function, which
contains the expression evaluation.

If strict mode is released, round brackets may be used instead of
v[5], if there is no function with the name v (else v(5) is a function
call with parameter 5). However, this is not recommended, and is
disabled by default.

#

// * Functions for Strings and Characters

// Strings in Euler are mainly used to hold expressions. An expression
// can be evaluated by the Euler interpreter using parameters. For
// many examples and a full reference refer to the documentation of
// Euler.

// Strings are also used for file names, error texts and other text
// information.

// The operator "+" can concatenate strings.

!ascii,char,substring,strfind,strrepl,strlen,tolower,toupper,strtochar,chartostr,strtokens,hardspace

  ascii(string) : The ascii code of the first letter in the string.
  char(n) : String containing only the character with ascii code n.
  
  substring(string,n,m) : The substring from n to m (including).
    Negative indices count from the back.
  
  strfind(string,sub[,n]) : Position of sub in the string. 
    The search starts after the n-th position.
    pos=0 means that sub was not found.

  strrepl(s,s1,s2) : Replace s1 with s2 in s
  
  strlen(string) : The lengths of the string.
  tolower(string) : The string in lower case.
  toupper(string) : The string in upper case.
  
  strtochar(string) : Vector of letters in the string.
  chartostr(vector) : String with characters in the vector.
  
  strtokens(string,{seperator}) : Vector of words in this string
    
  hardspace() : ASCII number of hard space character

The default separator string for strtokens() contains the characters
blank, tabulator, comma and semicolon.

The operator "+" can concatenate strings.

  >s="me and you", substring(s,strfind(s,"and",0),-1)
   me and you
   and you
  >strtokens(s)
   me
   and
   you
  >strtokens("A-B-C=D","-=")
   A
   B
   C
   D
  >chartostr(flipx(strtochar("the brand new car")))
   rac wen dnarb eht
  >s=12+char(hardspace())+13, s()
   12�13
   1213

See: key, chartoutf, utf, strxfind, strxrepl
#

!strxfind,strxrepl

The functions strxfind() and strxrepl() search with a regular
expressions. Regular expressions are a somewhat complicated tool to
match strings to pattern. The function strxfind() will return the
matched region and a list of submatches if the regular expressions
contained patterns in round brackets. The function strxrepl() can
use these submatches in the replacement string at any place.

  strxfind(string,expr[,start]) : Match with regular expression
    The function returns the position of the match, the matched
    string, and a string vector of submatches. If the match is not
    successful the function returns 0.
    
  strxrepl(string,expr,repl) : Replace with regular expression
    The function returns the string with replacements.

The most often used patterns are the following.

  . : any character
  [0-9] : range of characters
  [[:alpha:]] : character class (to be used in range)
  [^0-9 ] : excluded characters in range (digits and blank)
  .+ : repetition of any character (at least one)
  [0-9]* : repetition (any or no digit)
  \[, \\, \* : escaped format characters
  ^ : start of string
  $ : end of string
  (.+) : submatch region (looking for any character)
  (a|an) : alternative
  
In the replacement of strxrepl(), $0 is the complete matched string,
and $1, $2 etc. denote the submatches.

  >s="Albert Einstein 14.03.1879 Ulm.";
  >{pos,found}=strxfind(s,"[0-9\.]+"); found,
   14.03.1879
  >{pos,found,v}=strxfind(s,"([0-9]+)\.([0-9]+)\.([0-9]+)");
  >v
   14
   03
   1879
  >strxrepl(s,"([0-9]+)\.([0-9]+)\.([0-9]+)","$3-$2-$1")
   Albert Einstein 1879-03-14 Ulm.

See: strfind, strrepl
#

!utf,chartoutf,fromutf,toutf,Unicode

EMT has some support for Unicode. Strings can contain UTF-8 encoded
Unicode characters. These strings print correctly on the output, and
text in plots with such strings display the Unicode characters. 

The easiest way to generate a Unicode string is a string constant of
the form u"...". The string can contain HTML entities, which are
translated to unicode characters. You can find a list of entities in
the documentation of EMT and in the net. An example is
u"&alpha;". Unicode strings can also contain Unicode characters by
their number as in u"&296; is a German character!".

In fact any local characters will be translated into Unicode from
u"..." (or from the utf() function below).

  utf(string) : Translate entities to Unicode.

  chartoutf(vector) : Translate characters to a Unicode string.
    The characters are given by Unicode numbers. The
    converse function is strtochar(string), which
    recognizes a Unicode string.

  fromutf(string) : Translates a Unicode (UTF8) string
  toutf(string) : Translates a string to Unicode (UTF8)

Of course, not all Unicode characters can be translated to a normal
string.

See: strtochar
#

!key,testkey

These functions are for interaction with EMT, e.g., to animate a
graphics under user control.

  key() or key(text): Waits for a key.
    The optional text is displayed in the status
    line. The function returns the ascii key code,
    or the internal key code, mapped to codes from 0
    to 15.

  testkey(): Tests, if a key has been pressed.

See: ascii, wait
#

!input,lineinput

These functions provide a way for a simple user interface. EMT has no
dialogs.

  input(prompt) : Prompts the user for an expression. 
    Returns the value of this expression. In case of an
    error, the prompt will be repeated. The user can
    break out with escape.

  lineinput(prompt) : Prompts for a string, which is not interpreted.

See: evaluate
#

// * The Matrix Language

// The matrix language of Euler is the core of the functionality in
// Euler, which helps to avoid loops in many cases. Using the matrix
// languages allows for easy interactive computations.

// Most operators and functions in Euler work for real, complex and
// interval scalar, vector and matrix input, whenever that makes
// sense. The operators and functions obey to the rules of the Euler
// matrix language. 

// See: ../Programs/01 - The Matrix Language

// The following are functions that create or modify matrices and
// vectors.

// More functions are contained in @"util" or in @"linalg". For an
// introduction to matrices in Euler, read

// See: ../Programs/04 - Linear Algebra

!largematrices

Large matrices or vectors do not print in full size. To change this
toggle the behavior with

  >largematrices on
  >largematrices off

or use the operator showlarge.

  >showlarge random(10,10)

See: showlarge
#

!zeros,ones

  zeros([n,m]) zeros(n,m) zeros(n) : Matrix filled with with x=0.
  ones([n,m]) ones(n,m) ones(n) : Matrix filled with with x=1. 

  >shortformat; A=random(2,3)
    0.44462     0.29947     0.28269 
    0.88323     0.27091     0.70442 
  >B=ones(size(A))
    1           1           1 
    1           1           1 

See: size
#

// * Functions for Vectors and Matrices

// More functions for matrices and vectors can be found in the
// reference for Linear Algebra.

// See: linalg.html | Reference for Linear Algebra

!:,linspace

  i:n : The vector [i,(i+1),...,n] for integers i,n.

  x1:d:x2 : The vector [x1,x1+d,...,x1+k*d], 
    If d is negative, we get the vector [x1,x1+d,...,x1+k*d], where k
    is maximal such that x1+kd>=x1. For the comparison with the bound,
    the internal epsilon is used.

  linspace(a,b,n) : n+1 linear spaces values in [a,b], 
  	This includes a and b.

The colon ":" is also used for direct Maxima commands, for indices
in sub-matrices, and to put the current graphics to the notebook
window (at the end of the current command).

See: epsilon, equispace, chebzeros, :::, submatrix
#

!cols,rows,size,redim

  cols(A) : The number of columns of the matrix A.
  rows(A) : The number of rows of the matrix A.
  
  size(A,B,C,...) : The maximal size of A,B,C,... 
    This is used to define a matrix, which can hold
    the result of any operation between the compatible
    matrices A,B,C,... This is necessary, if map or
    the matrix language cannot be used, and a loop
    must be used instead. To access the k-th element
    of a matrix A flattened to a row matrix, use
    A{k}.

  redim(A,[n,m]), redim(A,n,m) : returns a matrix with the same content
    but different dimensions n times m.
    Fills with 0, if necessary.
 
  >A=zeros(3,4); size(A),
   [ 3  4 ]
  >rows(A), cols(A),
   3
   4
  >for k=1 to prod(size(A)); A{k}=k; end; short A
    1           2           3           4 
    5           6           7           8 
    9          10          11          12 
  >s=size(1:3,(1:3)')
   [ 3  3 ]

Note that A{k} refers to the k-th element of A with the rows
concatenated to one row.

See: matrixlanguage, {
#
!.,bandmult

A.B: Matrix multiplication.

  bandmult(A,B) : computes A.B and is a bit faster for sparse
    matrices.

This is just the ordinary multiplication of matrices. For sparse
matrices use cpxmult.

For large, sparse matrices, compress the matrices and use cpxmult.

See: ., cpxmult
#

!diag,setdiag,getdiag,band

  diag(A,k) : k-th diagonal of A (deprecated)
  getdiag(A,k) : k-th diagonal of A
  getdiag(A) : diagonal of A

  diag([n,m],k,v),diag(n,m,k,v) : nxm matrix with v on its k-th
    diagonal. (See diagmatrix(v,k)).
  setdiag(A,k,x) : A with the k-th diagonal set to x.

In these functions, k=0 is the main diagonal, k=-1 the diagonal below,
and k=1 the diagonal above. Note that setdiag() does not change the
matrix A, but returns a new matrix.

  band(A,n1,n2) : A, with A(i,j) set to 0, if i+j<n1 or i+j>n2.

See: diagmatrix

#

!prod,sum,colsum,cumprod,cumsum

These functions work for row vectors. In the case of matrices, they
work for each row of the matrix separately. E.g., sum(A) returns a
column matrix, with entries equal to the sums of the rows of A.

  prod(A) : A vector containing the products of the rows of A.
  sum(A) : A column vector containing the sums of each row of A.
  colsum(A) : A row vector containing the sums of each column of A.
  
  cumprod(A) : Matrix with the cumulative products in the rows of A.
    The result R has the same size as A. R[i,k] is the
    product of A[i,1] to A[i,k-1].
  cumsum(A) : Matrix with the cumulative sums in the rows of A.
  
  cummax(A) : Matrix with the cumulative maxima in the rows of A.
  cummin(A) : Matrix with the cumulative minima in the rows of A.
  
  >sum([1,2;4,3])
              3  
              7  
  >colsum([1,2;3,4])
  [4,  6]]
  >plot2d(cumsum(normal(1,1000)));
  >cumprod(1:5), (1:5)!
  [1,  2,  6,  24,  120]]
  [1,  2,  6,  24,  120]]
 
#

!dup,_,|

  dup(v,n) : duplicates the vector v n times 
    The duplication takes place vertically or horizontally
    depending on v. Row vectors are duplicated vertically,
    column vectors are duplicated horizontally.

  v_w : sets v atop of w.
    If one matrix has less columns than the other, it is filled
    with zeros. However, if v or w is a scalar value, this value
    is used for the fill. So v_5 adds one row filled with 5 to v.
    In any case, the number of rows is the sum of the rows of v
    and w, the number of columns is the maximum of the number of
    columns of v and w. This applies also, if v or w has zero
    rows.

_ is also used to access the built-in version of a function, if an
overwrite function exists. E.g., "_insimg" uses the built-in variant of
"insimg".

  v|w : sets v aside of w.
    Works analogously to v_w. So, v_5 will enter a column filled
    with 5 to v. The number of columns is the sum of the numbers
    of columns, and the number of rows is the maximum of the
    number of rows of v and w.

| : is also uses to append flags in Maxima compatibility mode and
symbolic expressions.

  s|t : does append strings, or strings and numbers. 
    The numbers will be formatted according to the current format.
    Note, that s+t will also append strings, or strings and
    numbers. Then s must be a string.

  >shortformat;
  >(1:3)_2
    1           2           3 
    2           2           2 
  >(1:3)'|2
    1           2 
    2           2 
    3           2 
  >random(3,3)_random(2,2)
    0.02744     0.70953     0.72939 
    0.58709     0.47649     0.58604 
    0.76816     0.54169     0.47627 
    0.57003     0.40318           0 
    0.13538     0.43876           0 
  >"me"|" and "|"you"
   me and you
  >"Result : "+1.5^2*pi
   Result : 7.06858347058
 
#

!any,all,nonzeros,mnonzeros,mget,mset,firstnonzero,lastnonzero

  any(A) : 1, if any entry in A is different from 0.
  all(A) : 1, if all entries in A are different from 0.

all(A) is equivalent to !any(A==0). For numerical comparison
respecting the internal epsilon, use A~=0.

In "if" clauses you must use any(v>2) to check, if any element of v is
greater than 2.

  nonzeros(v) : The indices of the non-zero elements of v.
    v must be a vector. The result is a row vector w, of
    at most the size of v.

  mnonzeros(M) : The indices of the non-zero elements of M.
    The result is a nx2 vector with rows of indices i,j.
    
  firstnonzero(M): Index of first non-zero element in each row of M
    If there is none, the result is 0. For a matrix, the result is
    a column vector.
   
  lastnonzero(M): Index of last non-zero element in each row of M
    Like firstnonzero.
   
  mget(M,k) : Get the elements of M with indices k.
    k is a nx2 vector of rows of indices i,j,
    
  mset(M,k,A) : Sets the indices of M in k to A.
    k is a nx2 vector of rows of indices i,j. Then M[i,j] is set
    to A[i,j].

See: ~=
#

// * Polynomials

// A Polynomial is stored in Euler in a vector of coefficients,
// starting with the lowest coefficient. Euler can solve complex
// polynomials, find polynomial fits and interpolations, and do some
// basic calculations of polynomials. 

// There are some utility functions to create and handle special
// orthogonal polynomials, like Chebyshev or Legendre polynomials. See
// @"gauss", @"functions".

!interp,divdif,interpval,polytrans,interpolation

Interpolation with polynomials. Euler uses the divided difference form
of the interpolation polynomial. This form requires that the
interpolation points are passed to the evaluation function of the
interpolating polynomial.

  interp(x,y) : divided differences of the polynomial interpolation.
    Interpolates (x(i),y(i)). Hermite interpolation is
    available with the function hermitinterp. For
    polynomial fit, use polyfit. 
  divdif(x,y) : Alias to interp.

  interpval(x,d,t) : evaluates the interpolation in x(i)  in t.
  divdifval(x,d,t) : Alias to interpval.

Both functions work with divided differences d in a vector [x0],
[x0,x1] etc. The functions work for complex interpolation too.

The function evaldivdif is an alias to divdifval with the t-argument
at the first place.

  polytrans(x,d) : transfer the divided differences into a polynomial.

  >x=[0,1]; d=interp(x,[1,1/2])
   [ 1  -0.5 ]
  >frac(interpval(x,d,[0,1])) // evalute in 0,1
   [1,1/2]
  >polytrans(x,d) // this is 1-0.5x
   [ 1  -0.5 ]
  >d=interp(1:5,[-1,1,-1,1,-1])
   [ -1  2  -2  1.33333333333  -0.666666666667 ]
  >plot2d("interpval(1:5,d,x)",1,5);

See: evaldivdif, interpolate, hermiteinterp, polycons, polyfit, remez
#

!polyadd,polycons,polydiv,polymult,polytrunc,polyval

Polynomials in Euler are stored in vectors starting with the constant
coefficient.

  polyval(p,x) : Evaluates p at x.
  polycons(v) : A polynomial with zeros v(i).
  polydiv(p,q) : {h,r}, where h is the result p/q and r the remainder.
  polymult(p,q) : Computes p*q.
  polyadd(p,q) : Computes p+q.
  polytrunc(p) : Truncates zero coefficients.

  >p=polycons(1:5), real(polysolve(p))
   [ -120  274  -225  85  -15  1 ]
   [ 1  3  4  2  5 ]
  >polyval(p,1:5)
   [ 0  0  0  0  0 ]

See: polysolve, polyroot, cheb
#

!polyroot

  polyroot(p,x) : Computes the root near x.

These functions use a Newton method close to the 0, and a descent
method away from a zero.

See: polyval, polycons, polysolve
#

// * File Input and Output

// With the following routines, and some utility functions described
// in other files, it is possible to write to files, and read from
// files.

// For more advanced functions to read and write matrices or other
// values, see @"io".

!changedir,path,load,home,homedir,userdir,start,eulerhome

Euler files (*.e) contain sequences of commands or definitions of
functions. They can be loaded with "load filename" or with the
load(filename) function. It is not possible to load files inside
functions. One loaded file can load another file. To skip parts of the
file use lines containing "comment" and "endcomment" or "stopload".

  load(string) : loads an Euler file (*.e)
    Interprets the file until it ends or until "stopload"
    is found. Inside a loaded file, another file can be
    loaded.

  changedir(string) : Changes the current directory.
    Returns the new directory. If the string is
    empty, it only returns the current directory.
    Note that the directory is changed
    automatically, if a new notebook is loaded or
    saved. 

  cd name : Change the directory to this file
    You can also use cd(expression), or cd "name". "cd" prints
    the current directory.

  home() : The home directory of the current notebook
  userhome() : The home directory of the user

  eulerhome() : The subdirectory Euler uf userhome().
    If the directory does not yet exist, it will be
    created. You should use this for temporary files.

  userdir() : The "Euler Files" directory.
  start() : The directory, where Euler started.

  path(string) : Sets a path to look for Euler files. 
    The load command will look through this path and
    choose the first available file. The path items must
    be separated by a semicolon. An example is
    ".;myspecial". This should not be changed by the
    user.

  load filename : loads an Euler file. 
    The name may be included in double quotes, or in
    round brackets (if it is a string expression). The
    command can also be used in a file to load another
    file. "load over filename" ignores protected
    functions.

  >filename=eulerhome()+"test.txt"
   C:\Users\Rene\Euler\test.txt
  >open(filename,"w"); writeln("First Line"); writeln("Second Line"); close();
  >printfile(filename)
   First Line
   Second Line
  >fileremove(filename)

  >changedir(eulerhome());
  >changedir(home());
  >cd

See: cd, comment, endcomment, printfile, open
#

!searchfile,dir,fileremove,filecopy,fileexists

  searchfile(pattern) : Searches for the file pattern.
  searchfile() : Searches the next file with this pattern.
  fileremove(file) : Removes a file

  filecopy(name1,name2) : Copies a file.
  fileexists(name) : File exists?

See: cd, dir
#

!open,close,eof

Euler can keep one file open for input and another file for output.

  open(filename[,type]) : opens a file with type="r","w","rb","wb"
    Opens for reading (type is "r") or writing
    (type is "w"). Binary mode can be achieved
    with "rb" or "wb". Default type is "r".

  close() : closes all opened files.
  eof() : returns 1, if the file is read completely.

See: putchar, putword, openurl
#

!putchar,putword,putlongword,putuchar,putuword,putulong

  putchar(c) : puts a character to a previous opened file.
    c is the ascii code of the character.

  putuchar(c) put c as unsigned character.
  putword(x) : puts x a s two bytes to the file.
  putuword(x) : put x as unsigned word.
  putlongword(x) : puts x as four bytes to the file. 
  putulongword(x) : The unsigned thing.

These functions use the internal format. They are useful for binary
output. For writing text, use write() and writeln().

See: write, getstring, open, close
#

!getword,getlongword,getuchar,getuword,getulongword,getline

  getchar() : reads one character from the file.
  getuchar() : for unsigned characters.
  getchar(n) : reads n characters, and returns in a 1xn vector.
  getword() : reads a word.
  getuword() : reads an unsigned word.
  getword(n) : reads n words.
  getlongword() : reads a long word.
  getulongword() : reads an unsigned long word.
  getlongword(n) : reads n long words.
  getline() : returns a line from the file.

See: write, getstring, open, close
#

!getstring,write,writeln

  getstring(n) : reads a string of length from an opened file.
  write(string) : writes a string to the open file.
  writeln(string) : writes a string to a line in the open file.

See: open, close
#

!urlopen,urlclose,urlgetline,urleof

EMT can get a connection to an internet URL for reading. It can read
line by line from this URL.

  urlopen(string) : Opens the connection
  urlgetleine() : Read a line from the URL.
  urlclose() : Closes the connection
  urleof() : End of file for reached?

See : open, toutf, fromutf
#

// * Expressions

// As mentioned in the section about strings, strings can hold
// expressions. Expressions can be evaluated using the evaluate
// function or its short form string(), resp. string(parameters). For
// examples, read the following introduction.

// See: ../Programs/00 - The Syntax of Euler

!eval,@(,evaluate,error,errorlevel

  eval("f",v,...) : calls the function f with parameters v,...

This is obsolete, because f(v,...) will work for strings containing
function names and also for strings containing expressions. 

  "expression"(...) : Euler evaluates strings containing expressions.
    Note that expressions in Euler are by default
    expected to be expressions in x, y, and z.
    Functions, of course, can use any variable name.
    The parameters of an expression in expr(...) are
    assigned to x, y, and z in this order. Additional
    parameters can be assigned using the form
    var=...

Evaluating an expression will use global variables, besides the
arguments passed to the evaluations. Global variables will be used
even if there is a local variable with the same name in the function
which contains the evaluation.

Expressions can be contained in call collections. The call collection
will then be of the form {{expression,parameter,...}}. This is just a
shortcut to expression(parameter,...).

A string of the form "@(a,b,c,...) expression" is evaluated as the
expression with parameters a,b,c etc. This works like an anonymous
function. It should be preferred to store functions in functions, not
in strings, however.

  evaluate(expression) : evaluates the expression string.
    This is obsolete, since expression() will do
    the same, and variables expression(x,y,z)
    will assign local variables x, y and z.
    Additional parameters can be assigned as
    var=... Global variables can be used.

  error(string) : issues an error and prints the message string.

  errorlevel(string) : evaluate the string
    It returns the 0 and the result if no error, else
    the error number.

  >function f(x) := x^3+x
  >f(0.5)
   0.625
  >eval("f",0.5)
   0.625
  >"f"(0.5)
   0.625

  >expr="x^3+x";
  >expr(0.5)
   0.625
  >expr:="a*x^3+x";
  >expr(0.5,a=1)
   0.625

  >expr="@(a) a^3+a";
  >expr(0.5)
   0.625

   >{f,res}=errorlevel("1/2"); f, res,
    0
    0.5
   >{f,res}=errorlevel("1/0"); f, res,
    1
    1

See: evaluate, expreval, collection
#

// * Intervals

// Euler contains an interval arithmetic. Most built-in mathematical
// functions and operators can handle intervals.

// The basic rule of interval arithmetic is that the result is an
// interval containing all possible results that can occur, if an
// input parameter is chosen for each parameter interval. Note, that
// if the same interval occurs twice in the parameter list, the
// intervals are independent. See the documentation for more details.

// For interval algorithms see @"interval". For an introduction, visit
// the following notebooks.

// See: ../Programs/14 - Exact Computation
// See: numerical | Interval Solvers and Guaranteed Solutions

!diameter,middle,left,right

  right(w) : right end of the interval w.
  left(w) : left end of the interval w.
  diameter(w) : right(w)-left(w)

These functions are functions for intervals, but they works for real
numbers too.

See: ~
#
!interval,~,±

  interval(a,b) : the interval [a,b].
  ~a,b~ : the interval [a,b].
  a±d : is like ~a-d,a+d~ (use shift-F8 for ?)
  ~a~ : returns an interval [a-eps,a+eps].

  >1±0.05
   ~0.95,1.1~
  >~-1,1~
   ~-1,1~
  >~4~
   ~3.999999999999999,4.000000000000002~

See: middle,left,right,expand,intersects,&&,||
#
!intersects,<<,<<=,expand

  intersects(a,b) : tests two intervals on non-empty intersection.
  a<<b : true if a is contained in b.
  a<<=b : true if a is contained in or equal to b.
  
  expand(x,d) : Expands a real number or an interval to a larger interval 
    The interval [x-d,x+d], if x is real, and an interval
    of d times the diameter of x, if x is an interval.

  >~2~ << expand(2,epsilon)
   1
  >expand(2,epsilon) << ~2~
   0

See: interval,&&,||
#

// * Functions for Plots

// Euler has the primary plot routines plot2d and plot3d. The
// following functions should only be used for special purposes. For
// more information, read the following notebooks.

// See: ../Programs/02 - 2D Graphics | 2D Plots
// See: ../Programs/03 - 3D Graphics | 3D Plots
// See: plot | Reference for Plots

!plots

Euler uses an external window for plots, but it can also copy plots to
the text window. The preferred way to plot is via the utility
functions plot2d and plot3d. These functions can plot

- 2D and 3D functions and parametric curves or surfaces
- implicit function of two or three variables
- anaglyph, contour, or level line plots
- user animated 2D and 3D plots
- complex nets

See: plot2d, plot3d
#
!aspect,getaspect

  aspect(x) : Sets the aspect ratio of the plot window.
    x=0 resets to the default values. This function will
    disable the "Graphics Window" settings in "Set Aspect"
    until aspect(0) or a restart of Euler.

  getaspect() : Gets the current aspect ratio of the Euler window.

See: aspect
#
!frame

  frame() : Draws the frame around the plot.
    The frame size is the graphics window minus the boundary
    for labels.

  framecolor(color) : Sets the color for the frame. 
    The white color 0 prevents the frame from
    drawing.

See: shrinkwindow, fullwindow, window
#
!coordinates

Euler uses plot coordinates or screen coordinates. 

The screen coordinates always range from 0 to 1024, no matter if the
actual screen format is square or rectangle. These coordinates are only
used by elementary plot functions, and should not be used by the
normal user.

Plot coordinates are set by the recent plot. They refer to an area in
the plane.

See: plot2d, setplot
#

!hold,holding,clg

Note that these functions should not be used with plot2d and plot3d.
To add another plot use add=1 for plot2d.

  hold : toggles holding of the graphics on or off. 
    This applies to the fact that plot clears the graphics
    normally.

  hold on : toggles holding on.

  hold off : toggles holding off.

  holding() : The holding state.

  holding(f) : sets the holding state. 
    f should be 1 or 0. Returns the old state.

  clg : clears the graphics screen.

See: plot2d, plot, cls
#

!huegrid,solidhue,solidhuecontour,subgrid

  huegrid(flag) : Turn the grid on or off.

  subgrid([ni,nj]) : Skip ni, nj gridlines in solid ior solidhue plots.
    Only grid lines i,j equal to 0 modulo ni,nj are
    drawn. This is used by plot3d to generate nice
    looking solid and hue plots.

Instead of these functions, use parameters of plot3d.

See: plot3d, solid, subgrid, huecolor
#

!keepsquare

  keepsquare(f) : sets a flag to determine the autoscaling. 
    If the flag is on, autoscaling will keep the y
    coordinates the same range as the x coordinates.

See: plot2d, plot
#

!plot,linestyle,setplot,linewidth,style

These functions should be replaced by the various options of plot2d.

  plot(x,y) : connects the points x(i),y(i) with lines. 
    The coordinates are plot coordinates, which are set
    before the plot from the range of x and y, unless
    setplot() has not been called before, or scaling is turned
    off. y can contain more rows as x. This will plot x,y[r]
    for all rows of y simultaneously.

  plot() : The x and y plot range (1x4 vector [x1,x2,y1,y2]).

  setplot([x1,x2,y1,y2]) : sets the plot coordinates.

  scaling(f) : Sets the scaling flag. 
    Returns the previous value. 

  linewidth(n) : Sets the width of the line. 
    Returns the old width.

  style(string) : Sets line styles and marker styles.
    Ignores wrong styles or style=none.

These functions should no longer be used and are replaced by plot2d.

See: plot2d, linestylestyle, rgb
#

!mark,markwithcolor,markersize,markerstyle

  mark(x,y) : Works like plot, but does not connect the points.
    Use plot2d with >points instead of this function.

  markwithcolor(x,y,c) : Uses the color c to mark x and y.
    This is used plot3d to mark points in 3D with
    different colors.

  markersize(n) : Sets the marker size in screen coordinates.

See: plot2d, coordinates, markerstyle
#

!bar,barcolor,barRGB,polygon

These functions should be replaced by the various options of plot2d.

  bar([xl,yu,w,h]) : Draws a rectangle 
    Use upper left coordinates (xl,yu), and lower
    right coordinates (xl+w,yu+h) in screen
    coordinates. The fill style is set with barstyle,
    and the color with barcolor. 

  barcolor([n]) : Sets the color index for the bar. 
    Returns the old color.

  barRGB(r,g,b) : Plots a matrix of red-green-blue values.
    The values r,g,b must of same size with values
    between 0 and 1.

  polygon(x,y,f) : Filled curve with optional outline.
    The fill style is set with barstyle, and the fill
    color with barcolor.

See: color, plotbar, polygon, barstyle
#
!style,barstyle,markerstyle,linestyle

  barstyle(string) : Sets the fill style for bars and polygons.
    Available are "#" for solid colors, "#O" or "O#"
    for solid colors with black boundary, "O" for
    boundaries only, "\", "/" "\/", "+", "-", "|" for
    hatched styles.

  linestyle(string) : Sets the linestyle.
    Available line styles are "-" solid, "--"
    dashed, "." dotted, "-." for dash-dotted, ".-."
    and "-.-" for dash-dotted, or "->" for arrows.
    There is also an invisible style "i". Returns
    the previous value.

  markerstyle(string) : Sets the style for the markers. 
    Available styles are "<>", "[]", "o", ".",
    "..", "...", "..#", "+", "|", "-" or "*", and
    "<>#", "[]#", "o#" for filled markers, and
    "<>w", "[]w", "ow" for markers filled with the
    background color.

These style functions return the old style, so that the plot function
can reset the previous style. This is necessary, since some plot
functions do not set the style, but use the global style.

style(string) : Set the style of lines and points.
    Combines line styles like ".", markerstyles like "m.",
    and barstyles like "b/". Does not return the old style.

See: plot2d, plot, mark, bar
#

!addpage,deletepages,showpage,pages,copytopage,copyfrompage

Functions for animation of plots in Euler. Pages are hidden graphics.
The user can add as many pages as the memory permits. The idea is to
create these pages once, and then play them in an animated sequence.
It is possible to hide the current page during the creation of the
sequence by showing some other fixed page.

Pages 1 and 2 can be combined for an anaglyph view. The graphics
function (usually plot3d) will plot on both pages with a slightly
different view. The combination merges both graphics in such a way,
that the use of red/cyan glasses is possible.

  addpage() : Copies the graphics to a new page.
  deletepages() : Deletes all pages.

  showpage(n) : Shows the page number n (1 to number of pages). 
    If n is 0, it shows the normal graphics. You can show
    page 1, and draw on page 0.

  showpage(-1) : combines page 1 and 2 to an anaglyph image, 
    and sets the graphics to anaglyph mode. This is
    cancelled with a new plot or clg().

  pages() : The number of pages.

  copytopage(n), copyfrompage(n) : Copies to or from the page number n
    to the current graphics

See: animate, anaglyph, plot3d
#

!anaglyph,setanaglyph

Anaglyph plot in Euler are realized by combining the pages 1 and 2 to
a single rec/cyan image with the command "showpage(-1)". Both pages
should contain two views of the same 3D scene with a slight different
view.

  setanaglyph(a) : Tilts the current view with the angle a to the right.

See: pages
#

!mesh,meshbar,meshfactor

Obsolete. Use plot3d instead.

  mesh(A) : Plots a simple 3D plot of a(i,j) over a grid of points (i,j).

  meshbar(A) : Works like mesh(A) with bars.
    The plot consists of columns of height a(i,j). Works
    for 1xn vectors too.

  meshfactor(f) : Dumps the mesh with the factor (0 to 1) in height.

See: plot3d
#

!solid,wire,fillcolor,project,view,twosides

These are elementary functions for plotting. In most cases, they
should be regarded as obsolete. Use plot3d instead.

  solid(x,y,z) : Plots a solid 3D plots of points x(i,j), y(i,j), z(i,j). 
    I.e., a rectangular grid (x,y) is mapped to these
    points. The two sided may have different colors,
    unless the twosides flag is off. Take care that the
    mapping is one-to-one and the plot does not
    self-intersect.

  solid(x,y,z,i) : Does not connect the i-th row to the i+1-th row. 
    This produces disconnected solid plots.

  solid(x,y,z,i,h,w,v,l) : Solid plot with shading and levels.
    
This is the basic function for plot3d, which should be used instead. h
is a matrix of hue values (between 0 and 1) for the shading. w is a
matrix of values for each matrix point. v is either a row vector of
level lines, which should be drawn, or a 2xn matrix of ranges of level
lines. In case of ranges, the areas in each triangle between two
bounds of each range are drawn with the contour color. v is ignored,
if it is none. l is a 1x2 vector of limits. If limits is none or not a
valid range, it is ignored. Triangles are clipped to these limits.

  wire(x,y,z) : Like solid, but does not fill the plot.
  fillcolor([n,m]) : sets the fill colors for both sides. 
    n,m are color indices (0..15) or rgb colors.

  project(x,y,z) : Projects the coordinates to the screen, 
    Just as in a solid or wired plot. Returns
    {vx,vy,vd}, where vx and vy are the screen
    coordinates, and vd is the distance to the eye. To
    mark a point in 3D, use this function, then
    fromscreen() and finally mark(), since mark works
    with plot coordinates.

  view([d,f,a,b]) : Sets the viewpoint of the camera. 
    d the camera distance to 0, f is the zoom factor,
    a the angle from the negative x axis and b the
    angle in height (measured in radial coordinates).

  twosides(f) : Turns the different colors for solid plots on or off.

See: plot3d, contourcolor, color, fromscreen, mark, solidhue
#

!color,wirecolor,huecolor,contourcolor,setcolor,resetcolors

  color(n) : Sets the color for the plot.
    Ignores n=none. It returns the current color if n is
    missing. The color can either be an index (0..15), or a
    RGB color, defined by the "rgb" function. Returns the old
    value. 

The predefined colors are: white=0,black=1,red=2,green=3,blue=4,
cyan=5, olive=6, lightgray=7, gray=8, darkgray=9, orange=10,
lightgreen=11, turquoise=12, lightblue=13, lightorange=14, yellow=15.
These names are defined as constants.

If the color is a vector of colors, each element will be used for one
row of a plot of a matrix.

  wirecolor(n) : Sets the color of the wires. 
    Ignores n=none.

  huecolor(n) : Sets the color for the shading. 
    Ignores n=none. If the color=-1, then the hue
    determines the color, and if color=-2 the hue is
    translated into a spectral shading.

  contourcolor(n) : Set the color for contours. 
    Ignores n=none.

  setcolor(i,red,green,blue) : Sets the color number i 
    Red, green, blue are for all future
    plots. The values must be in in [0,1].
    The colors can also be set in the Euler
    menu. The colors are reset at each
    start of Euler.

This function is not necessary for single plots, since colors can be
set individually, using e.g. color=rgb(r,g,b). The colors set in
this way are not saved by Euler globally.

  resetcolors() : resets all colors to the default values.

See: rgb, solid
#

!hatchgridsize,pixel

  hatchgridsize(pixels) : Sets the grid size for hatched fills.
    The grid size will be set to a multiple of
    8.

  pixel() : The width and height of a screen pixel in plot coordinates. 
    This helps avoiding unnecessary computations in the plot
    routines, especially for adaptive plots.

See: toscreen, fromscreen
#

!mouse,mousedrag,mousepos,mousestate

  mouse() : mouse() or mouse(string). Waits for mouse click or key.
    Waits until the user has clicked into the plot window.
    Returns the x,y-coordinates in plot coordinates. If the
    user pressed a key, the function will return the key, not
    an 1x2 vector.

  mousedrag() : Waits for mouse or keyboard events.
    The function returns {flag,m,time}, where flag is 0
    for keyboard events, 1 for mouse down, 2 for dragging,
    3 for mouse up. The result m contains the mouse
    position or the keyboard code. The time is the time of
    the event in milliseconds.

  mousestate() : 0 for mouse down and 1 for mouse up.
  mousepos() : The current mouse position in plot coordinates.

See: plot2d, setplotm, fromscreen, toscreen, dragvalues
#

!ctext,rtext,text,vtext,vctext,vutext,vcutext,textheight,textwidth,textcolor

The text functions draw text to the graphics window. The font is
fixed, and can be changed globally. These functions use screen
coordinates. To label anything in a 2D plot, use "label".

  text(string,[n,m]) : Draws the string to screen coordinates n,m
    The screen is aligned at the upper left edge.
    All text functions work in the form
    text(string,n,m) too.

  ctext(string,[n,m]) : Draws the string horizontally centered.
  vtext(string,[n,m]) : Draws a string downward.
  vctext(string,[n,m]) : Draws a string downward centered.
  vutext(string,[n,m]) : Draws a string upwards.
  vcutext(string,[n,m]) : Draws a string upwards centered.
  rtext(string,[n,m]) : Draws it right aligned.
  textheight() : The maximal text height.
  textwidth() : The average text character width.

  textcolor([n]) : sets the color index for text (0..15), 
    or returns the current color only.

See: label, coordinates
#

!setfont

  setfont(lines,name) : Sets the graphics font.
    This sets a font with size and name for one
    session. The font is automatically applied to
    the current graphics. Euler can currently use
    only one font. The default is "Courier New"
    and 40 lines per screen. If the name is blank,
    the font is not changed. Use this for special
    purposes or for small prints, where larger
    font sizes are important.

The utility function setfont(fontsize,size,name) provides a better
interface.

  setfont() : Resets the old font size and name.

See: setfont
#

!density

  density(A) : Draws the elements a(i,j) 
    it uses darker and lighter values in a square grid seen
    from above. You should scale the matrix to [0,1) since
    only the fractional part is used.

Use plot2d instead.

See: contour
#

!getred,getgreen,getblue,putred,putgreen,putblue

These functions transfer one RGB encrypted pixel color to red, green,
blue values in the interval [0,1], and reverse. Used by loadpixels(),
savepixels(), and by rgb(r,g,b), getrgb(x).

  getred(x) : Gets the red part of an RGB color
  getgreen(x) : Gets the green part of an RGB color
  getblue(x) : Gets the blue part of an RGB color
  
  putred(x) : RGB color with this red part
  putgreen(x) : RGB color with this green part
  putblue(x) : RGB color with this blue part

See: rgb, getrgb, loadrgb, savergb
#

!loadrgb,savergb

Load and save an array of pixels into an image file of PNG format.

  loadrgb(filename) : loads a PNG into an RGB array
  savergb(x,filename) : saves an RGB array into a PNG file

To convert the RGB format to its channels, use getred, getgreen, getblue,
or getrgb. To convert the channels into an RGB format use rgb.

See: rgb, getred, getgreen, getblue, putred, putgreen, putblue, getrgb
#

!contour

Use plot2d or plot3d instead.
 
  contour(A,v) : Draws contour lines of a(i,j) at heights v(k). 
    a(i,j) is interpreted as the values of a function f
    at (i,j). Note, that i and j are always scaled to a
    square grid, unless you specify a non-square plot
    window. The function does not draw the plot
    coordinates, so they must be set manually using e.g.
    xplot.

The advanced utility function plot2d should be used instead of this
elementary function.

See: density, fcontour, fniveau, contourcolor
#

!plotarea,fullplotarea,margin

  plotarea(x,y) : Determines the necessary plot range

  fullplotarea() : Returns the full plot area including margin.
    This works like plot(), but takes care of margins.

  margin(x) : Sets a margin between 0 and 1 around the plot.

Use the parameters of plot2d instead.

See: plot, plot2d
#
!insimg,loadimg,loadanaglyph

  insimg(n,"name",flag,crop) : Inserts the graphics into the notebook.
    The graphics is scaled to n lines.
    "name" is optional and appended to the
    file name on export. flag is for
    anti-aliasing, and crop for the crop
    (1x4 vector). This function is
    overloaded with a more comfortable
    function.

  loadimg(n,"filename",flag) : Loads an image into the notebook.
    Loads a graphics from a file with maximal
    height n. If larger, the graphics scales
    down.

  loadanaglyph(n,"left,"right") : Generates an anaglyph.
    Loads two graphic files and combines
    them to one anaglyph image. The files
    must have the same size, and be at
    least 16x16. The image is inserted
    into the notebook with height at most
    n.

For these three functions there are service functions with more
flexible parameters.

See: insimg, loadimg, loadanaglyph
#

!postscript,pswindow

postscript "file.ps" dumps the graphics to the file in postscript
format. To set the size of the output in cm, use pswindow([w,h]).
w=h=15 is the default.

#

// * Programming Euler

// The most part of Euler is programmed in the Euler language itself.
// These programs are interpreted, which makes them slower than the
// built-in functions. For practical purposes, the speed difference is
// very often negligible, especially, if the programs use the matrix
// language of Euler.

// For an introduction to the programming see the following notebook.

// See: ../Programs/05 - Euler Programs

!function,endfunction,return,parameter,none,alias

A function in Euler has the following form.

  function name (parameter names)
  ...
  return ...
  ...
  endfunction

A function can contain more than one return statement. If the function
does not contain a return statement, it returns "none", a string with
one character equal to 1. This result will yield no output.

If the function line in the notebook ends with three dots ..., the
function can be interpreted with one stroke of the return key. To edit
such a function use the internal editor with F9, or click into the
body of the function to edit the function.

See: Keyboard

  >function f(x) ...
$  if x>0 then return x^3
$  else return x^3
$  endif;
$endfunction

One-line functions return only the result of a simple expression.
They are defined in the following simplified form.

  >function f(x) := x^x
  >f(1:5)
   [ 1  4  27  256  3125 ]

A function can return multiple values. The syntax uses {...}. The
return values can be assigned to variables.

  >function sort2 (a,b) ...
$  if a<b then return {a,b}
$  else return {b,a}
$endfunction
  >{c,d}=sort2(5,4); [c,d]
   [ 4  5 ]

If the return values are used as arguments to other functions, only
the first one is used by default. This can be changed with the args
modifier.

There are functions, which cannot be called. The purpose of these
functions is to provide help in the usual form for DLL functions, or
for Maxima functions. Use the keyword comment to define such
functions.

  function comment name (parameters)
  ## Comment ...
  endfunction

You can define an alias name for a function with

  alias aliasname original

See: return, parameters, ##, protect, overwrite, maxima, symbolic, dll
#
!repeat,break,continue,while,until,end,for,loop,#,index

repeat; ...; end;

This is an eternal loop. 

  until condition;
  while condition;

These statements must be inside a repeat loop. The until statement
finishes the loop if the condition is true. It jumps after the
end of the loop. The while statement finishes the loop if the
condition is false.

  for i=n to m; ...; end;
  for i=n to m step i; ...; end;
  v=...; for x=v; ...; end;

This is the for loop. It can also be used to iterate through a row or
column vector v as above. Changing v, or the loop step, or the end
values inside the for loop has no effect on the loop. The vector v is
copied to an allocated memory area. Again, return or break end the
loop. 

  loop 1 to n; ...; end;

This is a faster loop. The loop index can be called with index() or
with the special symbol #. Again, return or break end the loop.

  break;
  continue;

Each loop can be finished with return or break (usually in an if statement),
where break jumps to the end of the loop. The continue command jumps
to the start of the loop. 

  >function test ...
$  s=0;
$  n=1;
$  repeat
$    s=s+1/n;
$    while s<10;
$    n=n+1;
$  end;
$  return n;
$endfunction
  >test
   12367

Loops can also be used in the command line, as long as they fit into
one line.

  >s=0; loop 1 to 10; s=s+#; end; s,
   55
  >s=0; for i=1:10; s=s+i; end; s,
   55
  >s=0; for i=1 to 10; s=s+i; end; s,
   55
  >s=0; i=1; repeat; s=s+i; i=i+1; until i>10; end; s,
   55
  >s=0; i=1; repeat; s=s+i; i=i+1; while i<=10; end; s,
   55

See: not, and, or
#
!if,elseif,endif,else,then

  if condition then ...; endif;
  if condition then ...; else; ...; endif;
  if condition then ...; elseif condition; ...; endif;
  if condition then ...; elseif condition; ...; else; ...; endif;

The command "then" can be omitted, though this is not encouraged. The
commands can be used in the command line, as long as they fit into a
single line.

Note that loops and ifs cannot be used in one-line functions.

  >function signumstr (x)
$  if x<0 then return "negative"
$  elseif x==0 then return "zero"
$  else return "positive"
$endfunction
  >signumstr(-1), signumstr(0), signumstr(1)
   negative
   zero
   positive

See: not, and, or
#
!argn,totalargn,args,getarg,arg1,arg2,arg3

The arg... group of functions gives you access to unnamed arguments of
functions. Unnamed arguments get the default names arg1, arg2, arg3,
... and can be accessed by this name or by the argument number.

  argn() : The number of arguments, given to the function.
  args(n) : returns all arguments from the n-th argument on, 
  getarg(n) : get the n-th argument to a function call.

  args() : ll parameters from the first unnamed argument 
    or the first argument after the semicolon ";" (semicolon
    parameters).

Note that args() can deliver multiple returns which have the args flag
(see the documentation for "return"). They can all be used as
arguments to another function. In the following example, we pass a
function as a parameter to another function, which calls it with
args.

  >function f(a,b,c) := a*b*c
  >function g(h) := h(args())
  >g("f";5,6,7)
   210

See: function, return
#
!comment,endcomment,skipcomment,//,/*,*/,##,..,...

comment
....
endcomment

Brackets for a comment in a file. The load command will show the
comment, unless this is turned off. comment and endcomment must be on
a line of their own.

  comments on : turns comments on.
  comments off : turns comments off.

  skipcomment
  ....
  endcomment

Like comment, but will never print.

  /*
  ....
  */

Shortcut for skipcomment. In functions /* ... */ can also be used.

  // is a one line comment, which is removed from a function definition.

In functions, lines starting with ## are the help text for the
function, if they follow the function header immediately. Otherwise,
they are ordinary comment, but will not be removed from the function
body. So they are visible with "type function".

  .. skips rest of this line and continues with next line.

  ... works like .., but sends all lines as a multi-line command.

See: load, function
#

!parameters,arguments

Parameters of functions can have default values. If the parameter has
a default value in the function definition as in f(x,n=3), this value
is used, unless two arguments are passed to f. If a parameter is
missing as in h(x,,4), the default value for the second parameter is
used.

  >function f(x,a=5) := a*x
  >f(2)
   10
  >f(2,3)
   6

Parameters with default values can be set with assigned arguments in
the form "f(10,a=5)". This allows very flexible functions, where the
order of the assigned arguments does not matter. A shortcut for a
boolean assigned argument is ">a" (for a=1) or "<a" for (a=0).
Moreover, "=a" will set an assigned parameter with the same value as
the variable "a" in the calling program.

By default, it is only possible to pass arguments with values if the
corresponding parameter with default value does exist. But the
modifier "allowassigned" in the definition of the functions allows
additional assigned arguments. These arguments work like variables in
the function.

Parameters of functions are passed by value, unless the parameter
name starts with %... (See the "global" command for global variables).
Even, if the parameter is passed by reference, it can only change its
value, not its type. If it is a matrix, it cannot change its size.

  >a=4;
  >function change$x (x) ...
$  x=5;
$endfunction
  >change$x(a); a,
   4
  >function change$x (%x) ...
$  %x=5;
$endfunction
  >change$x(a); a,
   5

Vectors and matrices are passed by reference. So if you change elements
those elements will be changed in the original matrix. The matrix
cannot be replaced completely, however. Even "v=v" in the function
already copies the matrix argument "v" to a local copy.

  >v=1:5
   [ 1  2  3  4  5 ]
  >function change$w (w) ...
$  w[1]=2;
$endfunction
  >change$w(v);
  >v
   [ 2  2  3  4  5 ]

If the call contains a semicolon instead of the colon to separate
the parameters as in f(x,y;4,5), the parameters 4,5 are extra
parameters, which can be passed from f to other functions using the
args() function. These parameters are called semicolon parameters. For
an example, see the "args" function.

Semicolon parameters can not be used inside a function, and can only
be uses via the args() function as parameters for other functions.
References to variables, which are given as a semicolon parameter, are
visible however. This does even work in evaluations of expressions,
when args() is used in the parameter list of the evaluation.

  >expr="a*x";
  >function f(expr) := expr(2,args());
  >function g(expr,a) := f(expr;a)
  >g(expr,4)
   8

Parameters can be restricted in the types of the values they can be
assigned to, when the function is called. Possible restrictions are

  real, complex, interval, integer: include scalars, vectors or matrices
  scalar: no vector, no matrix
  vector: row vector, includes scalar
  column: column vector, includes scalar
  numerical: not a string or compressed matrix
  string: excludes vector of strings
  cpx: compressed matrix
  positive, nonnegative: additional hint

These types can be combined. E.g., "complex vector" will accept all
row vectors of type complex or real. 

There are the shortcuts 

  number = real scalar
  natural = non-negative integer
  index = positive integer scalar
  indices = positive integer vector

These parameter types are restrictions. There is one parameter type,
which is not a restriction.

none: Allows the special string none for this parameter.
This is automatically assigned to a parameter with default value none.

  >function f(x:number) := x^2
  >f(1:5)
   Function f needs a scalar for x
 
   Error in :
   f(1:5)
    ^
  >f(5)
   25

The scalar type is often necessary. To allow for a vector, use "map".

Assigned parameters are parameters with a default value as in
f(x,y,c=5). These parameters must be the last parameters in the
parameter list, even after semicolon parameters. As a special
convenience >c is equivalent to c=true, and <c is equivalent to
c=false. Boolean parameters are often used in plot2d and plot3d.

Arguments can be passed to a function with no parameters. The
function names these parameters as "argX", where X is the position
number of the parameter. Additional arguments are not possible for
functions with parameters. In this case the parameter and argument
counts must agree.

See: args, argn, useglobal, global
#
!useglobal,global,setglobal

useglobal : Allows reference to global variables in functions.
global variable: Allows reference to a global variable in functions.
setglobal variable: Sets the variable global in all functions.

Note that useglobal is set in all one-line functions automatically.

  >function f(x)
$  useglobal; // alternatively: global a;
$  return a*x;
$endfunction
  >a=4; f(2)
  8

See: function
#
!map

Vectorization

Mathematical functions implemented in Euler functions should be ready
to handle vector input. Often, this is automatic. But if the function
contains conditional branches, or other more complicated routines,
that might not be the case. To make sure, you can plot the functions
and use them in numerical routines, you can define the function as a
map function at compile time.

  function map f (x:scalar; p:vector)
  ...

In this case, f will map to the elements of a vector x. I.e., it will
compute the value for each element of x one by one. All parameters
after a semicolon are excluded from the mapping.

It is also possible to map a function at run time. Use either of the
following commands.

  map("f",X,Y,...) : maps the function f to the elements of X,Y. 
  fmap(X,Y,...) : does the same.

The mapping obeys the rules of the Euler matrix language. The result
of f must be a scalar numerical value. Parameters after a semicolon
instead of a comma are protected from the mapping, and are used as
they are.

You can map to a function with no result (return missing). The map
function will return no result too. No result is simulated in Euler
with the value none.

The following function restricts to a number, but since "map" is used,
it can map itself to vectors or matrices. It will still not work for
complex scalars or matrices.

  >function map test (x:number) ...
$  if x<0 then return 0
$  else return x^2
$endfunction
  >test(-1:1)
   [ 0  0  1 ]

See: function, none
#
!protect,overwrite

protect: protect all current function definitions and variables 
from overwriting.

Variables starting with default... are not protected. The protection
can be ignored with a global flag in the Euler menu.

overwrite: keyword to enable the redefinition of a protected function.

Functions can be protected just as built-in functions. By default,
protected functions can not be redefined. But the overwrite keyword
unlocks the protection.

function overwrite f (...)
...

See: function
#
!trace,traceif
Traces Euler functions.

  trace : toggle trace mode
  trace on,off : set trace mode
  trace function : toggles tracing the function

While tracing is on, the following keys are available.

  cursor down : single step
  cursor right : step over subroutines
  cursor up : go until return
  cursor left : end trace
  insert : evaluate expression
  escape : abort execution

In functions, it is useful to start tracing conditionally.

  traceif condition : start tracing, if the condition is true

You can then inspect local values at this point, and continue execution
with the cursor left key.

  trace errors : trace on errors

This is useful to start tracing on errors. The user can inspect
variables. In a function, only local variables are available. An empty
input aborts the execution.

#
!{,},multiple

  return {a,b,c} : Returns multiple values from a function.

  {a,b,c}=f(...) : Assigns these values to variables.

  A{k} : The k-th element of the matrix A, as if A was flattened 
    to a row matrix. Equivalent to redim(A,1,prod(size(A)))[k],
    but faster. Indices out of bounds produce an error. This
    works for string matrices too.

  A{i,j} : The i,j-th element of the matrix A, often like A[i,j].
    But for vectors, the index exceeding 1 will be set to 1.
    This is one way to program functions obeying the matrix language
    of Euler, since f(A,B) will work for a row vector A and B,
    combining the proper elements, if A{i,j} and B{i,j} are combined.
    A{i,j} cannot be used for assignments. Indices out of bounds
    produce an error. The easier way is to use the keyword "map" in
    the definition of the function.

>A=[1,2;3,4]
             1             2 
             3             4 
  >A{3}
   3
  >v=1:3
   [1,  2,  3]
  >v{2,2}
   2

See: =,{{,}}
#

!{{,}},collection,call

Collections in EMT can contain any other data type. They behave like
immutable lists. Use collections to return multiple values from a
function in one EMT object (in contrast to multiple returns).

  {{a,b,c,...}} : Creates a collection of objects

Collections can also catch multiple returns of a function.

  >c={{sort(y)}}

Moreover, collections can be executed, if the first element is the
name of a function or an expression. We call this a "call collection".
The rest of the list is passed to the function as extra parameters.
This is an alternative to semicolon parameters in calls to plot
functions or numerical algorithms.

  >function f(x,a) := a*x^2
  >plot2d({{"f",5}},-1,1):

In expressions, the extra parameters (besides the default x,y,...)
must be named elements of the collection.

  >L={{"sin(a*x)",a=6}}; L(4)

See:{,},glist,;,evaluate
#

!operator,postfix,prefix,strong,prefixline

This allows to define functions which do not have to use parameters in
brackets. Examples are "longest ..." or "fraction ..."

  function operator op (x,y) := ...
  function postfix f (x) := ...
  function prefix g (x) := ...

Define operators and postfix functions. Usage:

4 op 5
5 f
g "test"

The operators bind weakly. 

1 + 5 op 6 + 1 -> (1+5) op (6+1)

The modifier "strong" makes them bind strongly.

  >function strong operator op (x,y) := ...
  >1 + 5 op 6 + 1 // is like: 1 + (5 op 6) + 1

There is no strong version of prefix functions.

The modifier "prefixline" takes the rest of the input line as a string
parameter for the function. This is for special purposes only. It is
currently used in the interface to Scilab to enter commands to Scilab
in the following way

  >sl v=1:20
#

// * Numerical Algorithms

// There are more numerical algorithms in Euler than these core
// functions. You find an overview on the following pages.

// See: ../Programs/06 - Numerical Analysis
// See: ../Programs/11 - Differential Equations

and in some other introduction notebooks.

!nelder,brent

  brent("f",a,d,eps) : returns a minimum close to a. 
    The function goes away from a with step size d
    until it finds a good interval to start a fast
    iteration. Additional parameters are passed to
    f.

The function fmin is recommended instead of this function.

  nelder("f",v,d,eps) : return a minimum close to v.
    For functions f(v), accepting 1xn vectors v.
    The parameter d is the initial simplex size.
    eps is the final accuracy.

See: nelder,neldermin,brentmin,fmin,fmax
#
!runge1,runge2

  runge1("f",a,b,n,y) : does n steps of the Runge-Kutta method 
    to solve y'=f(x,y). y may be a 1xn vector or a
    real (the initial value), (a,b) is the
    x-interval.

  runge2("f",a,b,y,eps,step) : does the same with adaptive step sizes.
    The initial size is step, and the
    accuracy is eps.

The user should use runge, and adaptiverunge instead.

See; runge,adaptiverunge
#
!toeplitz,toeplitzsolve

  toeplitz(v) : returns the Toeplitz matrix T to the vector v. 
    v must be a 1xn vector with odd n=2m+1. T has the
    property that T[i,j]=v[m+i-1-j]

  toeplitzsolve(v,b) : Solves T\b fast, where T is the Toeplitz matrix to v.

#
!svd

  svd(A) : computes {U,v,W}, the singular value decomposition of A.
    A must be a real matrix. U,V are orthogonal, and we get
    A=U.diag([cols(A),cols(A)],0,v).W'

A must have more rows than columns.

See: svdsolve,fit
#
!accu,accure,accuim,accua,accub

The long accumulator in Euler is mainly used to compute an exact scalar
product, necessary for residuum iteration. However, it can be used for
other purposes as well. Euler cannot add or multiply two accumulators,
but can add any value, or a product to the accumulator.

The accu... functions gets the content of the long accumulator (or its
real, imaginary (for complex accus), upper or lower (for interval
accus) part.

See: accuload, accuadd, residuum
#
!accuload,accuadd

  accuload(v) : Loads the sum of the vector v to the accumulator.
  accuload(v,w) : Loads the scalar product of v and w.
  accuadd(v) : Adds the sum of the vector v to the accumulator.
  
  accuadd(v,w) : Adds the scalar product of v and w. 
    Both must be 1xn vectors.

See: accu, accure, accim, accua, accub, residuum
#
!residuum

  residuum(A,x,b) : Computes A.x-b exactly to the last digit. 
    A, x and b must be compatible matrices.

See: xlgs
#

// * Functions for Units

// Units can be converted in Euler. However, Euler does not check for
// correct application of units. It simply converts numbers. The final
// results should be stored in the international system (IS).

// See: units | Units defined in Euler
// See: ../Programs/00 - The Syntax of Euler.html#Units | Syntax of Units

!units,easyunits,->

Units are simple conversion constants in Euler. All units end with $,
but it is possible to use them without $, if easyunits is set.

  easyunits on/off: sets or releases use of units without $.
  easyunits: toggles use of units without $.

The -> operator converts units. If the conversion goes to a string, the
units in this string will be used, and the units will be printed after
the result.

  >2km/h->miles/min
   0.0207123730746
  >2km/h->" m/s"
   0.555555555556 m/s

Note, that it is safest to always use units with the dollar sign. This
will avoid confusion with variables. Variables with the same name
override units.
 
See: Units
 
#

// * Functions for Maxima

// The main interface to Maxima should be the symbolic expression and
// the symbolic function. With the help of these, Maxima integrates
// seamless into Euler.

// More commands are defined in a utility file. Those commands start
// with mxm..., and use Maxima to provide symbolic results at run
// time.

// There are also commands in Maxima, which extend the Maxima syntax
// for Euler.

// For a start and more information consult the following pages.

// See: ../Programs/10 - Maxima
// See: ../Programs/00 - The Syntax of Euler.html#Symbolic_Expressions_and_Variables | Symbolic Expressions
// See: maxima | Functions for Maxima

!maxima,symbolic,&,&=,&:,::,:::,@:,::=,&:=,&&=,$

Maxima is a powerful, open Algebra system contained in Euler. By
default, the Maxima process starts in the background, whenever Euler
starts or is restarted. Note that Euler restarts by default when a new
notebook is loaded.

Maxima can be used directly or via symbolic expressions. The direct
mode has a compatibility mode, which makes the syntax of Maxima and
Euler more similar. It is the preferred mode.

  :: ... Maxima command in compatibility mode.
  maxima ... is an alternative way to start a Maxima command.
  ::: ... Maxima command in direct mode
  : ... Maxima command in direct mode (disabled by default).

  &expression : evaluates a symbolic expression. 
    Returns the string evaluated in Maxima. An alternative
    is ::expression. See below for differences to the 
    original Maxima syntax.

  >&(x+4)^2 | expand
         2
        x  + 8 x + 16
  >&"diff(x^5,x,2) with x=5"
              2500

The result in Euler is a string with the symbolic flag. It can be used
line any other expression.

  >plot2d(&diff(sin(x)*x,x),0,2pi);

Symbolic expressions are scanned by EMT before the evaluation in
Maxima, unless the Maxima command starts with the character !. The
following replacements take place.

  @var allows to insert numerical values into the expressions
  [...] allows matrices in the EMT syntax
  % is replaced by the recent expression
  | is replaced by a comma to allow flags
  := is replaced by :
  __ is replaced by _
  \c is replaced by c

function f(x) &= expression defines a function for Maxima and Euler.
The expression is evaluated before the function is defined.

  >expr &= x^4;
  >function f(x) &= diff(expr,x)
           3
        4 x

Symbolic functions assigns a symbolic expression to a variable in
Maxima and Euler, after the expression has been evaluated by Maxima.

a &&= expression assigns an expression only in symbolic form. The
expression is evaluated before it is defined. This is useful if the
expression contains functions, which cannot be evaluated numerically.

  >function f(x) &&= expression 
  
defines a function for Maxima only. The expression is not evaluated in
the case. It works like a macro. So this definition can be used for
functions, which need to evaluate at run time with additional
information.

  >function D2(f,x) &&= diff(f,x,2);
  >&D2(x^5,x) 
           3
       20 x

&:expression returns the string, evaluated in Maxima, and evaluates
the result in Euler. In functions, the string is inserted into the
function body at compile time. Finish the command with , or ;, or
enclose the expression in quotes.

  >function f(x) &= x^4;
  >function df(x) := &:diff(expr,x);
  >type df
   function df (x)
   useglobal; return 4*x^3; 
   endfunction

@:expression works like &:expression (deprecated)

  a &:= value sets the value for both Euler and Maxima.
  a ::= value does the same (deprecated)

  $expression :  a symbolic expression like &expressions. 
    But it prints with Latex, if Latex is installed.
    There might be a short delay, if such a command is
    executed.

See: mxmstart, mxmset, mxmget, function
#
!@,@@

  @expr : Is replaced with the content of the variable expr 
    in symbolic expressions, Maxima commands, and function
    definitions at compile time. It is an alternative to
    symbolic expressions, in case the expression is defined in
    an Euler string only. But it will also work for numerical
    values and even matrices.

  >expr:="x^5"; &diff(@expr,x)
    4
    5 x
  >a=solve("x^x",1,y=2), &bfloat(@a^@a)
   1.55961046946
    1.9999999999999988897769753748435b0
  >v=1:5; &map(sqrt,@v)
    [1, sqrt(2), sqrt(3), 2, sqrt(5)]

In function definitions, @expr inside strings is not replaced at
compile time. Therefore, &"diff(@expr,x)" in functions replaces @expr
at run time, and computes the derivative then.

  >function dtest (expr,var) := &"diff(@expr,@var)"
  >type dtest
   function dtest (expr, var)
   useglobal; return &"diff(@expr,@var)" 
   endfunction
  >dtest("x^4","x") 
          3
       4 x

@@ : In Maxima and symbolic expressions, this allows the input of a
"@".

See: mxm
#
!mxm

  mxm("diff(x^2,x)") : Evaluates in Maxima. 
    The result is a string. This is deprecated.
    Use &diff(x^x,x) instead.

Note that @a is replaced by the content of the variable a, if @a is
contained in the Maxima command.

  >expr := "x^3-x"
   x^3-x
  >mxm("diff("+expr+",x)")
   3*x^2-1
  >&diff(@expr,x)
          2
       3 x  - 1

See: mxmeval, @
#
!maximamode,euler

Toggles Maxima mode. If on, all commands are sent to Maxima. In maxima
mode, 

  euler command

will send the command to Euler.

  maximamode: Toggles the mode
  maximamode on: Compatibility mode
  maximamode direct: Direct mode
  maximamode off: Maxima mode is off

See: :::,::,:
#
!latex:,maxima:

If LaTeX is installed, formulas can be used in comments, in the
command output and in plots. 

  >latex: expression

Produces a Latex formula. Of course, the expression must be a valid
Latex code.

  >maxima: expression

Inserts a formula for this symbolic expression. Any symbolic
expression or variable can be used.

See: texpng, texrgb
#

// * Extensions of Maxima in Euler

// The following functions are symbolic functions defined in a file,
// which is loaded every time Maxima starts. These functions are
// extensions to the Maxima syntax specific to Euler.

!grad,hesse,diffat

grad(expression) symbolic: Gradient of expression
    The variables are sorted alphabetically.

gradient(expression,variable) symbolic: Gradient of expression

hesse(expression) symbolic: Hessian of expression
    The variables are sorted alphabetically.

hessian(expression,[variables]) symbolic: Hessian of expression

diffat(expression,x=value{,n}) symbolic: Evaluated differentiation
    Works like diff(expression,x,n) with    
    x=value

#
!crossproduct,scalp

  crossproduct(v,w) symbolic: Cross product in 3-space

  scalp(v,w) symbolic: Scalar product

#
!getlagrange,solvelagrange

  getlagrange(f,g,[variables]) symbolic: Get Lagrange equations
    for extreme values of f(variables) with the condition
    g(variables)=0.

  getlagrange(f,g) symbolic: Get Lagrange equations
    Use the variables of f.

  solvelagrange(f,g,[variables]) symbolic: Solve Lagrange equations
    for extreme values of f(variables) with the condition
    g(variables)=0.

  solvelagrange(f,g) symbolic: Solve Lagrange equations
    Uses the variables of f.

#
!with

  with: expression with [var=value,var=value,...] (symbolic)
  with: expression with var=value (symbolic)

Evaluate the symbolic expressions and assign variable values. Works
like at(expression,assignments)

#

// * Global Variables

// EMT is based on a variable stack. The usual global variables can be
// read and their value can change, but neither their type nor their
// size. Thus EMT needs some functions for global variables which can
// be changed.

// Global variables are cleared when the notebook is reset.

!gset,gvar,gremove,gclear

These functions handle global variables with all supported values
in EMT.

  gset("name",value) : Sets a global variable "name" to a value
  gvar("name") : Reads the global variable "name"
  gremove("name") : Removes the global variable
  gclear() : Removes all global variables

As a shortcut

  a$$ = value
  var = a$$

can be used.

See: glist

#

!glist,glistadd,glistinsert,glistvar,glistdelete,glistlength,glistremove

Global lists can take any supported values in EMT. New elements can be
added at any position, but appending a new element is the most
efficient way to add an element. Access to any element is fast.

  glist("name") : Create a list "name"
  glistget("name",position) : Get an element from a list
  glistadd("name",value) : Append a value to a list
  glistinsert("name",position,value) : Insert an element to a list
  glistput("name",position,value) : Replace an element in a list
  glistdelete("name",position) : Delete an element
  glistlength("name") : Length of a list
  glistremove("name") : Delete a list

  listlists : List of all global lists
  listlists name : all global lists with name containing the string
    Similar to listvars

See: gset

#

// * Various Core Functions

!matlab

  matlab on
  matlab off
  matlab

Toggle the Matlab mode. In this mode the syntax of Euler is closer
to Matlab. For a reference read the documentation about Euler and
Matlab.

#
!tic,toc

tic; ... commands ... toc; measures the time of the commands
in millisecond resolution.

  >tic; inv(normal(100,100)); toc;
   Used 0.047 seconds
 
#
!time,wait

  time() : The time in seconds.

  wait(n) or wait(n,text): waits for n seconds (text for status line).
    This functions interrupts, if the user
    presses a key. Returns {time,key} the time
    waited, and a key, if one was pressed.

See: key
#
!epsilon,setepsilon,localepsilon,relerror

  epsilon() : The internal epsilon used for various purposes.
  setepsilon(x) : sets the internal epsilon.
  localepsilon() : sets the epsilon locally for a function.

Some numerical algorithms allow to set the local epsilon using an
assigned argument eps=...

  relerror(x,y) : |x-y|/|y| for y<>0, and x for y~=0.

  >bisect("x^2-2",0,2)
   1.41421356237
  >bisect("x^2-2",0,2,eps=0.001)
   1.41455078125

See: ~=
#
!free,hexdump,memorydump,list,listvar,listvars,forget,clear,clearall,remvalue,type

  free() : The free space on the stack.

  list : lists all built-in functions, commands and all functions.
  list string: lists only items containing the string.

  listvar: lists all variables, their types and sizes.
  listvar string: lists all variables containing the string.

  listvars: lists all variables, their types and sizes.
    Alias to listvar.
  listvars string: lists all variables containing the string.
    Alias to listvar string.

  clear var,... : removes the variables.
  clearall : removes all user variables, 
    but not default variables and %variables.

  remvalue var,... : removes the variables

  forget function,... : removes the functions.

  hexdump var : dumps the variable or user defined function var 
    in hexadecimal form.

  type function : Type the code of a function
  type var : Type the content of a variable

The list functions can be replaced by the help window and its
wildcards.

See: restart
#
!restart

Restarts Euler and its notebooks. All variables and user functions
are lost. Usually, this function is called using the menu entry.

See: clear, forget, remvalue, quit
#
!name

  name(var) : The name of the variable var.

See: varwrite
#
!%,%%

  %: is the result of the previous command (not assignment). 
    This works in Maxima and Euler. In symbolic expressions, % refers
    to the previous Euler result. If this is another symbolic
    expression, % is replaced by this symbolic expression (in
    round brackets). In Maxima lines, it refers to the previous
    Maxima result. Over several command lines, is safer to use
    variables.

  %%: Is used in Maxima block commands to refer to the previous result.
    So &(x^2,%%^2) yields x^4.

#
!relax

  relax : Command to relax strict mode, when reading an Euler file.

Strict mode inhibits certain old constructions. It can be switched off
in the Euler menu. For Euler files some of these regulations are
relaxed, but not all. To relax all regulations, start the Euler file
with the relax command.

#
!addmenu,submenu

  addmenu command : Adds the command to the user menu.
    The command can contain place holders as ?item.
    Whenever the user places the cursor in front of
    the question mark and starts typing, the place
    holder is removed. If the line contains a place
    holder, the cursor right key positions the cursor
    in front of the next place holder.

  submenu command : Generates a new submenu in the user menu.
    The default submenu is the filename of the Euler
    file, or "Other".

The user menu is cleared at each restart.
#

// A dynamic link libraries (DLL) is a Windows feature to add
// functions to a running program. In Euler, it is possible to
// compile external functions in DLLs. You can find more information
// on this in the following notebook.

// See: ../Programs/20 - Compiled Code in Euler

!dll,closedll,tccompile

  dll(name,function,n) : Loads the function f (a string) from the dll
    with the name, assuming it has n arguments.

  closedll(name) : Unload the DLL.

  tccompile filename : Compile the C file with tccompile.
  
#

!errors,isNAN,NAN,underflows

Handles generation of NAN (not a number) or error messages.

  errors on, off: Turn error messages on or off

  NAN : Not a number
  isNAN(x) : Tests, if x is a NAN

  underflows on, off: Turns underflows for ^ and exp on and off. 
    The default is off.

#

!setkey

  setkey(n,text) : Sets the keyboard function key n to the text.

Some function key do not work without the Ctrl or Shift key.

#

!exec,message,execwrite,execwriteln,execread

  exec("command","arguments","directory",print,hidden,wait) : external command.

For details have a look at the utility function exec. This will block
by default and wait for user confirmation.

  execwrite(string) : Write a string to an open pipe.
  execwriteln(string) : Write a string and a new line to an open pipe.

  execread() : Reads strings from an open pipe.
    The return value is a vector of strings, one for each
    line.

  message("This is a message") : Shows a dialog with this message. 
    Use "First line"+nl$+"Second Line"
    for line breaks.

See: cd, exec
#

!yacas,yacasclear,yacasmode

Yacas is no more recommended for Euler. If you still want to use it,
you need to enable it in the menu. Then you can enter a Yacas commands
with >>...

  yacas(expr) : lets Yacas evaluate the expression. 
    It returns the result string or the Yacas error
    message.

  yacasclear() : starts a new Yacas session.

  yacasmode (on|off) : toggles or sets Yacas mode.

In Yacas mode, it is possible to use Euler commands with euler ...

  >yacas ... : Sends a command to Yacas in Euler mode.
  >> ... : Sends a command to Yacas in Euler mode.

  >yacas("D(x) x^x")
   x^x*(Ln(x)+1)

See: converty, y2matrix, y2vector, ynewton, mxm, mxmeval
#

!eulerarg,script

  eulerarg(n) : Returns the n-th arg of the argument lines for scripts.

Run euler with the "-script eulerfile.e" parameter and additional
parameters to keep the GUI opening.

#

// * Python

// Python code can be written and used from Euler. For this, Python
// 2.7 must be installed. It is not sufficient to download
// python27.dll. A full installation is required.

!py,python,pyeval,pyget,pyset

py: command 
  >>>> command

Execute a Python command.

For multi-line Python commands, multi-line Euler commands can be used.

py: ...
command ...
command ...
command

Another method is the following, which uses a function body. Press F9
to edit the function, or click into the function.

function python ...
Commands
endfunction

These two methods to run Python commands collect all output and print
it after they have finished. They are not designed for interactive
Python programs.

function python f(x) ...
  Commands
  return value
endfunction

This defines the function f(x) in Python, which can called as f(x) in
Euler. The function can have a help line ## ... like any other Euler
function. In fact, an Euler function is defined, which is flagged to
call Python.

  pyeval("function",argument1,argument2) : Evaluates a Python function.
  py$function(argument1,argument2) : Evaluates a Python function.

  pyset("varname",value) : Sets a variable in Python.
  pyget("varname") : Gets a variable from Python.

Euler translates reals to float or integers, vectors to lists,
matrices to lists of lists, strings to strings. The string
"py$function" is translated to the Python function "function".

  python("Command") : Executes a Python command
  python(["Command1","Command2"]) : Executes a multi-line Python command

  loadpython(filename) : Loads a Python file.
    This will collect all output from the file
    like py: ...

See: keyboard
#
