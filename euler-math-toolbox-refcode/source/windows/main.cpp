// #undef CATCH // defined in the project section for release
// #define DUMP // undefine for dumps in message boxes instead of c:\\euler\\dump.txt

#include "windows.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <mmsystem.h>
#include <io.h>
#include <direct.h>
#include <Shlwapi.h>

#include "../header.h"
#include "../sysdep.h"
#include "euler.h"
#include "../help.h"
#include "meta.h"
#include "../yacas.h"
#include "../maxima.h"
#include "colors.h"
#include "text.h"
#include "windowsmeta.h"
#include "graphicswindow.h"
#include "main.h"
#include "edit.h"
#include "windowsframes.h"
#include "windowsgraphics.h"
#include "images.h"
#include "helpwindow.h"
#include "spell.h"
#include "windowspython.h"
#include "translate.h"
#include "../mainloop.h"
#include "../globalvars.h"
#include "../aliases.h"
#include "files.h"

int logging=0; // Create log file

int exception=0; // exception code after crash
int exceptiontype=0; //

int linelength=70; /* width of text screen */
int fixlinelength=1; // fix the width of the screen to 70
int textwidth=500; // width of text in pixels
int editing=0; /* editing is swithced on, command input is expected */
int waiting=0; // Flag, if Euler is waiting for a user key (or computing).
int lefteditlimit=1; // For editing a line, this is the start (after the prompt).

int editcomment=0; // Mode for editing a comment instead of a command

int script=0; // Script mode

int textmode=1; /* which of the screens shows, text or graphics */
int newgraphics=0; // graphics screen has been cleared
int usecolors=1; /* old fashioned for non-color graphics */
int mousewaiting=0; /* waiting for mouse clicks (see mmouse) */
int mousedragging=0; /* wait for mouse drags too */
int scalelines=1; /* scale the line thickness to screen size */
int saveimages=1; /* save images along with notebooks */
int imagesindirectory=1; /* save images along with notebooks */
int askconfirmations=1; /* ask before leaving Euler etc. */
int createbb=0; /* create a bb file for LaTeX PNG output */
int statushelp=1; /* enable help in the status line (turn off for sloooow machines) */
int automaticreturn=0; /* true if return was generated by autorun */
int alwaysrestart=1; /* will restart Euler at each loaded notebook */
int saveprofile=0; // save profile in Euler start directory
int startmaxima=1; // start Maxima at program start
int enablemaxima=0; // enable direct mode in Maxima
int startyacas=0; // start Yacas at program start
int enableyacas=0; // enable Yacas
int brackets=1; // require correct brackets
int assignments=0; // require correct assignments
int spaces=1; // require spaces between commands
int commas=1; // require commas in matrix lines
int startinmaximamode=0; // start in Maxima compatibility mode
int usedirectmode=0; // then use direct mode
int allowoverwrite=0; // allow overwriting protected functions
int allowvaroverwrite=1; // allow overwriting proteced function names for variables
int alwaysrelax=0; // relax strict mode in each file
int reportindex=1; // report index out of bounds
int savewithantialias=1; // save graphics with anti-aliasing
int conditionvectors=0; // can use vectors in if conditions
int antialiasgraphics=1; // antialias the graphics window
int antialiasfactor=3; // factor for antialiasing
int latexantialiasfactor=3; // factor for antialiasing
int neverantialiasinsimg=0; // never antialias insimg images
int helpintitle=0; // show help in window title, not in status line
int allowsymbolicdp=0; // allow ::expression for symbolic expressions (not "::...")
int matlab=0; // matlab mode
int enlarge=0; // show text screen in maginification
double enlargefactor=1.2; // factor
int cropsquare=1; // use a square rectangle in the graphics window
int savecropsquare=1; // permanent value of cropsquare
double aspect=1.0; // use this aspect (1=square, 1.5=3:2)
double saveaspect=1.0; // permanent value of this
int boldfont=0; // use a bold font in the graphics window
int fatterlines=0; // use fatter lines
int fontlines=1; // linethicknes depends on font
int gfontfixed=0; // do not used fixed width for graphics fonts
int largeimages=0; // Keep large images for all images
int answermaxima=0; // Answer Maxima silently
int checkforupdates=0; // Check for Updates when Euler starts
int htmlutf=1; // Export HTML as UTF-8
int utf=1; // Export Notebooks as UTF-8
int smallscreen=0; // Small Screen with less than 800 Pixel height
int exportlatexasmathjax=0; // Export Latex formula as MathJax
int disablelatex=0; // Disable Latex
int displaymathjaxaslatex=1; // Display MathJax with Latex
int generatesvg=0; // Generate SVG in insert_image
int uselargeimagesforhtml=1; // Large images are linked from HTML file
int openexportedhtml=1; // Open exported web page in browser
int openexportedpdf=1; // Open exported PDF
int generatelatexfileonly=0; // Do not translate with Latex
int generatexhtml=0; // Generate XML header on export and use .xhtml ending
int createsvg=0; // Create and use SVG for HTML export
int savecompressedsvg=0; // Compress SVG files
int foldallmultilines=0; // Fold all multiline commands
int respectfolding=0; // Respect folding on HTML export
int respectfoldinglatex=0; // Respect folding on Latex export
int noreformat=0; // Use paragraphs
int linux=0; // run under wine
int latexantialias=1; // antialias Latex formulas
int spellcheck=0; // spell check
int english=1; 
int german=0;
int insertsmaller=0; // insert smaller images
int systemscaling=0; // scale bitmaps with GDI
int sharper=0; // sharper anti-aliasing
int second=0; // this is the second process

int latexams=1;
int latexlarger=0;
int latexmagnify=1;
int latexgreen=1;
int latexcleanup=1;
int latexsilent=1;
int latexnoerrors=0;
int latextransparent=0;
int latexkeeplarge=1;

int allowcommandonce=0;
int allowdllonce=0;
int allowpythononce=0;

int wantquit=0; /* Euler will quit on next opportunity */
int runcommands=0; /* Euler runs a notebook from start to end */
int updatecomments=0; // Update comments while running commands automatically
int skipbreaks=0; // skip the breaks (empty lines) while running commands
int automatic=0; // automatically answers requests for keys
int agmode=0; /* show two graphics frames (0 and 1) in anaglyph mode */

int askexec=1; // Ask to allow execs generally

int commentx=300,commenty=100,commentw=500,commenth=400; // size and position of comment window
int wscreen,hscreen;

int python27=1; // Determines Python 2 or 3

char hardspace; // character of hardspace (e.g. 0x60), determined in main()

int useutf = 0; // use UTF for text screen
int CODE_PAGE = 0; // User this codepage (0 = current default)

String smaximacallstring;
String smaximacalldir;

#ifdef WIN64
int stacksize=1024,graphicssize=256; // default stack size in MB
#else
int stacksize=512,graphicssize=128; // default stack size in MB
#endif

CriticalSection critical("Graphics"); // contains static functions to enter and sections
	// critical for multitasking

String wantload; // load an euler file or notebook at next opportunity

String profiledir; // directory to search for a profile
String eulerfiles; // subdirectory of the start directory, if it exists (for USB installation)

// Instance of the profile class to hold the Euler profile.
// The Profile class uses the Windows registry.
Profile profile("EULER-95\\settings"); 

Meta *meta; // The main graphics content.

String Printer(""),PrintText(""); 
	// Strings to hold the printer and the printed help text for the next print.

PS *ops=0;

void crash_message ();

HANDLE CurrentProcess=0; // The current external process (is interrupted with ESC)

//****************** one window ************************

int onewindow=0; // experimental, alpha, do not use!
int textx=10,texty=10,textw=600,texth=800; // experimental

int intextwindow=0; // no graphics window
int showgraphics=0; // show graphics instead of text (only if intextwindow)

//******************* Font ******************************

// Hold the names of the fonts. The user can change the font.
// The chosen font names are saved to the registry.
String TextFontName("Courier New");
String GraphicsFontName("Arial");

int gscreenlines=40; // Size of the graphics font as a fraction of the screen height.
int tfontheight=16; // Size of the text font in absolute measure.
int rememberfonts=0; // Enabled only, if the user calls the font settings successfully

// Hold the currently chosen fonts.
Font *courier=new Font(TextFontName,15,Font::normal,Font::fixed);
Font *courierbold=new Font(TextFontName,16,Font::bold,Font::fixed);
Font *courierlarge=new Font(TextFontName,20,Font::bold,Font::fixed);
Font *couriersmall=new Font(GraphicsFontName,13,boldfont?Font::bold:Font::normal,gfontfixed);
Font *couriersmalldown=new Font(GraphicsFontName,13,boldfont?Font::bold:Font::normal,gfontfixed,2700);
Font *couriersmallup=new Font(GraphicsFontName,13,boldfont?Font::bold:Font::normal,gfontfixed,900);

//******************** Main Window **********************

Windows windows;

// Instance of Program. Initializes the application for Windows.
Program program;

WindowClass eulert("EULERT",IDI_Notebook);
WindowClass eulerg("EULERG",IDI_Euler,
	WindowClass::noclose|WindowClass::vredraw|WindowClass::hredraw);

TextWindow textwindow("");

StatusBar *SB;

Font *helpfont=new Font(TextFontName,tfontheight,Font::normal,Font::fixed);

//****************** Resolution ********************

String Resolution("",64);

/**
Prepend the resolution to s.
*/
char *addres (char *s)
{
	static char res[1024];
	strcpy(res,Resolution.text());
	strcat(res,s);
	return res;
}

//***************** Main Window ********************

String StatusText("");

void setstatus (char *text)
{	
	if (!cropmode) 
	{
		StatusText.copy(text);
		textwindow.setstatus(StatusText);
	}
}

//****************** Menu *******************************

void dochange (int id)
{
	switch (id)
	{
		case IDM_foldallmultilines :
			textwindow.update();
			break;
		case IDM_german :
		case IDM_english :
			resetspell ();
			if (spellcheck) text->spellcheck();
			break;
	}
}

class EulerMenu : public Menu
{
public :
	EulerMenu (StandardWindow &window) : Menu(window)
	{}
	void changed (int id)
	{
		dochange(id);
	}
};

EulerMenu menu(textwindow);

//**************** Computation thread *******************

ComputationThread computation;

#include <eh.h>

int fcompute ()
{   
#ifndef CATCH
	main_loop(computation.argc(),computation.argv());
	return 1;
#endif
	__try
	{
		main_loop(computation.argc(),computation.argv());
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		exception=GetExceptionCode();
		exceptiontype=2;
		end_maxima();
		crash_message();
		doexit();
		exit(0);
	}
	wantquit=1;
	textwindow.usermessage(TextWindow::message_quit);
    return 0;
}

void setstyles();

int doreplay ()
/*
Repaint the meta graphics to the bitmap 
and update the graphics window.
*/
{   
	if (agmode)
	{	
		if (!frames.makeag(graphicswindow->bitmap())) return 0;
		graphicswindow->update();
		return 0;
	}

	setstyles();
	critical.enter();
	meta->replay(ops);
	critical.leave();

	graphicswindow->update();
	return 0;
}

Thread graphicsreplay (doreplay);

void setstyles ()
{
	set_styles(antialiasgraphics,linewidth(graphicswindow->width(),1,!fatterlines)/2.0);
}

void GraphicsWindow::sized ()
/*
The windows has been resized by the user.
Start timer number 3. with 1/4 sec.
*/
{	
	setstyles();
	if (Tsized) delete Tsized;
	Tsized=new Timer(*this,250,3);
}

/****
The graphic screen has coordinates from 0.0 to 1024.0 (double).
There should be a function, which computes the correct screen
coordinates from these internal ones.
****/

void graphic_mode (void)
/***** graphics
	Switch to graphics. Text must not be deleted.
	On a window system make graphics visible.
*****/
{   
	if (!textmode) return;
	if (intextwindow)
	{
		if (showgraphics) textwindow.update();
	}
	else
	{
		graphicswindow->top();
		graphicswindow->foreground();
	}
	textmode=0;
	newgraphics=1;
}

void text_mode (void)
/***** text_mode
	Switch to text. Graphics should not be deleted.
	On a window system make text visible.
*****/
{   
	if (textmode) return;
	if (intextwindow)
	{
		showgraphics=0;
	}
	textwindow.update();
	textwindow.top();
	textwindow.foreground();
	textmode=1;
	graphicswindow->Dragging=0;
	setstatus("");
}

/*********************** input routines **********************/

int mouse (double *x, double *y, char *statustext)
/****** mouse
	wait, until the user marked a screen point with the mouse.
	Return screen coordinates.
******/
{   
	mousewaiting=1;
	if (!textmode && intextwindow)
	{
		showgraphics=1;
		textwindow.update();
	}	
	graphicswindow->update();
	if (!editing)
	{	
		textwindow.stopcomputingtimer();
		setstatus(statustext);
	}
	computation.suspend();
	if (!editing)
	{	
		textwindow.startcomputingtimer();
	}
	mousewaiting=0;
	graphicswindow->mouse(*x,*y);
	int code=textwindow.code(),scan=textwindow.scan();
	if (code==0) return scan;
	return code;
}

int mouse (double *x, double *y)
{	return mouse(x,y,"Waiting for mouse press or key.");
}

int mousedrag (double *x, double *y, long *time, int *keycode, char *statustext)
/****** mouse
	wait, until the user marked a screen point with the mouse.
	Return screen coordinates.
******/
{   
	mousewaiting=2;
	if (!textmode && intextwindow)
	{
		showgraphics=1;
		textwindow.update();
	}	
	graphicswindow->update();
	if (!editing)
	{	
		textwindow.stopcomputingtimer();
		if (*statustext) setstatus(statustext);
	}
	computation.suspend();
	if (!editing)
	{	textwindow.startcomputingtimer();
	}
	mousewaiting=0;
	graphicswindow->mouse(*x,*y);
	*time=graphicswindow->Time;
	*keycode=textwindow.code();
	int scan=textwindow.scan();
	if (*keycode==0) *keycode=scan;
	if (*keycode) return 0;
	else return graphicswindow->Type;
}

int mousestate (double *x, double *y)
{
	*x=graphicswindow->X;
	*y=graphicswindow->Y;
	return graphicswindow->Type;
}

void doruncommands ();

int wait_key (int *scan, char *statustext)
/*****
	wait for a keystroke. return the scancode and the ascii code.
	scancode should be a code from scantyp. Do at least generate
	'enter'.
*****/
{   
	CaretOn.set();
	textwindow.usermessage(TextWindow::message_caret);
	waiting=1;
	if (!editing)
	{	textwindow.stopcomputingtimer();
		setstatus(statustext);
	}
	if (!textmode && intextwindow)
	{
		showgraphics=1;
		textwindow.update();
	}	
	graphicswindow->update();
	computation.suspend();
	CaretOn.clear();
	textwindow.usermessage(TextWindow::message_caret);
	if (!editing)
	{	textwindow.startcomputingtimer();
	}
	waiting=0;
	*scan=textwindow.scan();
	int code=textwindow.code();
    if (code!=0) text->changed(1);
	return code;
}

int wait_key (int *scan)
{	return wait_key(scan,"");
}

int test_key (void)
/***** test_key
	see, if user pressed the keyboard.
	return the scancode, if he did.
*****/
{   return textwindow.scanescape();
}

int test_code (void)
{   return textwindow.code();
}

/***************** clock and wait ********************/

double myclock (void)
/***** define a timer in seconds. 
******/
{	return (double)clock()/CLK_TCK;
}

void getnow (int *year, int *month, int *day, 
	int *hour, int *minute, int *second, int *milliseconds,
	int utc)
{
	static SYSTEMTIME time;
	if (utc) GetSystemTime(&time);
	else GetLocalTime(&time);
	*year=time.wYear;
	*month=time.wMonth;
	*day=time.wDay;
	*hour=time.wHour;
	*minute=time.wMinute;
	*second=time.wSecond;
	*milliseconds=time.wMilliseconds;
}

void printnow (char *s, int size,
	int utc)
{
	static SYSTEMTIME time;
	if (utc) GetSystemTime(&time);
	else GetLocalTime(&time);
	GetDateFormat(LOCALE_USER_DEFAULT,DATE_LONGDATE,&time,0,s,size);
	strcat(s," ");
	int k=(int)strlen(s);
	s+=k;
	GetTimeFormat(LOCALE_USER_DEFAULT,0,&time,0,s,size-k);
}

int sys_wait (double time, int *scan, char *statustext)
/***** Wait for time seconds or until a key press.
Return the scan code or 0 (time exceeded).
******/
{   
	if (!textmode && intextwindow)
	{
		showgraphics=1;
		textwindow.update();
	}	
	if (time<1)
	{	
		*scan=0;
		if (!intextwindow) graphicswindow->doupdate();
		long ti=(long)(time*1000);
		if (ti<=0) ti=1;
		Sleep(ti);
		return 0; 
	}
	if (!editing && time>=1)
	{	
		textwindow.stopcomputingtimer();
		setstatus(statustext);
	}
	textwindow.starttimer((long)(time*1000));
	waiting=1;
	graphicswindow->update();
	textwindow.update();
	computation.suspend();
	if (!editing && time>=1)
	{	textwindow.startcomputingtimer();
	}
	waiting=0;
	int c=textwindow.code();
	if (time>=1) *scan=textwindow.scan();
	else *scan=0;
	return c;
}

int sys_wait (double time, int *scan)
{	
	return sys_wait(time,scan,"");
}

/**************** directory *******************/

String homedir;
String startdir;

char dirpath[521];

char *cd (char *dir)
/***** sets the path if dir!=0 and returns the path
*****/
{	
	static char path[1024];
	_chdir(dir);
	if (_getcwd(path,1024)) return path;
	return dir;
}

int makedir (char *s)
{
	_mkdir(s);
	return exists(s);
}

char *dir (char *pattern)
/***** Search a pattern if not 0, else research 
******/
{	
	static struct _finddata_t ff;
	static int another=0;
	static LONG handle;
	static char name[1024];
	if (another && !pattern)
	{	
		if (_findnext((LONG)handle,&ff)==-1)
		{	another=0; return 0;
		}
		else if (ff.attrib & _A_SUBDIR)
		{
			strcpy(name,ff.name);
			strcat(name,"/");
			return name;
		}
		else return ff.name;
	}
	if (pattern)
	{	
		handle=(LONG)_findfirst(pattern,&ff);
		if (handle!=-1)
		{	
			another=1;
			if (ff.attrib & _A_SUBDIR)
			{
				strcpy(name,ff.name);
				strcat(name,"/");
				return name;
			}
			else return ff.name;
		}
	}
	return 0;
}

void sethomedir ()
{	cd(homedir);
}

char * gethomedir ()
{	return homedir;
}

void setstartdir ()
{	cd(startdir);
}

char * getstartdir ()
{	return startdir;
}

char * getmaximadir ()
{
	if (smaximacalldir.length()>0) return smaximacalldir.text();
	else return getstartdir();
}

int file_copy (char *source, char *destination)
{
	return CopyFile(source,destination,0)!=0;
}

int file_exists (char *name)
{
	return exists(name);
}

String workdir;

/***************** div. ***********************************/

void getpixelsize (double *x, double *y)
/***** Compute the size of pixel in screen coordinates.
******/
{	
	*x=1024.0/graphicswindow->displaywidth();
	*y=1024.0/graphicswindow->displayheight();
}

void gflush (void)
/***** Flush out remaining graphic commands (for multitasking).
This serves to synchronize the graphics on multitasking systems.
******/
{
}

void sys_playwav (char *filename)
{	PlaySound(filename,0,SND_FILENAME);
}

/**************** Text screen ***************************/

void clear_screen (void)
/***** Clear the text screen
******/
{	text->clear();
	textwindow.stophelptimer();
}

/********************** Text output ***************************/

/****
The following text screen commands should be emulated on a graphic
work station. This can be done by a standard emulator (e.g. VT100)
or within a window displaying the text. Additional features may be
added, such as viewing old text. But the input line should be
visible as soon as a key is pressed by the user.
****/

extern char* BOM;

void gprint (char *s)
/*****
Print a line onto the text screen, parse tabs and '\n'.
Printing should be done at the cursor position. There is no need
to clear the line at a '\n'.
The cursor should move forward with the print.
Think of the function as a simple emulator.
If you have a line buffered input with echo then do not print,
when the command line is on.
*****/
{   
	// dump("%d characters (first %d): %s",strlen(s),*s,s);
	if (!textwindow.focus())
	{	
		textwindow.top();
    	textwindow.foreground();
	}
	if (*s!='\n') text->delline();
	text->inserttext(s);
	if (error)
	{	runcommands=0;
		skipbreaks=0;
	}
}

void edit_off (void)
/* the command line is no longer in use (graphics or computing) */
{	
	editing=0;
	text->backup();
	computation.priority(0);
	text->removeoutput();
	textwindow.update();
	textwindow.startcomputingtimer();
	textwindow.stophelptimer();
}

void edit_on (void)
/* the command line is active */
{	
	editing=1;
	computation.priority(2);
	graphicswindow->update();
	if (!agmode) showframe(0);
	text->settype();
	text->nextprompt();
	text->showcursorline();
	textwindow.update();
	text_mode();
	newgraphics=0;
}

void clearudfinput ()
{
	if (udf) text->clearudfinput();
}

void doopenfinish (char *filename);
void saveandexporthtml ();
int saveit ();
void doexporthtmlcontinue (int flag);

extern CriticalSection textcritical;

void edit (char *inputbuffer)
/*
Needs to be defined by each client of the Euler core.

This function is called from the computation thread, which is
stopped here, until the editing is finished.
If runcommands>0, we run the next command line automatically.
*/
{	
	waiting=1;
	textcritical.enter("start edit");
	if (!udf)
	{
		if (text->cursorline()->length()==0) 
			text->cursorline()->type(TextLine::prompt);
		text->cursorline()->cat(">");
	}
	else 
	{	
		if (text->cursorline()->length()==0) 
			text->cursorline()->type(TextLine::udf);
		text->cursorline()->cat("$");
	}
	text->cursorright();
	edit_on();
	text->showcursorline();
	if (!wantload.empty()) 
	{	
		textwindow.sized();
		doopenfinish(wantload);
		// Sleep(500);
		wantload.clear();
		runcommands=0;
		skipbreaks=0;
	}
	textcritical.leave();
	textwindow.update();
	if (automatic || 
		(runcommands && (!text->isAfterBreak(text->cursorline()) || 
			(text->cursorline()->next() && skipbreaks)))
		)
	{	
		if (updatecomments) text->updatecomment();
		runcommands--;
		automaticreturn=1;
		text->shift(0);
		if (automatic && text->cursorline()->next()==0)
		{	
			if (automatic==2) 
			{
				openexportedhtml=0;
				doexporthtmlcontinue(saveit());
			}
			automatic=0;
#ifdef YACAS
			exit_yacas();
#endif
			end_maxima();
			exit(0);
		}
	}
	else
	{	
		CaretOn.set();
		textwindow.usermessage(TextWindow::message_caret);
		automaticreturn=0;
		runcommands=0;
		updatecomments=0;
		if (generatesvg)
		{
			generatesvg=0;
			saveandexporthtml();
		}
		skipbreaks=0;
		textcritical.enter("set cursor in start edit");
		lefteditlimit=text->cursorpos();
		textcritical.leave();

		// stop the computation
		computation.suspend();
		
		CaretOn.clear();
		textwindow.usermessage(TextWindow::message_caret);
	}
	if (strlen(text->cursorline()->text()+lefteditlimit)+1<MAXLINE)
	{	
		strcpy(inputbuffer,text->cursorline()->text()+lefteditlimit);
		put_history(inputbuffer);
	}
	else
	{	
		print("Line too long!");
		error=1;
	}
	edit_off();
	// empty key strokes
	textwindow.code(); textwindow.scan();
	waiting=0;
	output("\n");
}

/************ ask user dialog ************************/

class AlwaysButton : public ButtonItem
{   
	public :
	AlwaysButton (int id, Dialog &d)
		: ButtonItem(id,d)
	{}
	int command (LPARAM p)
	{	
		return 0;
	}
};

int askuser (char *text)
{
	Dialog dr(textwindow,IDD_Allow);
	TextItem v(ID_Version,dr,text);
	AlwaysButton b(ID_Always,dr);

	dr.carryout();
	return dr.result();
}

/********** execute programs *************************/

HANDLE progeulerin,progout,progeulerout,progin;
HANDLE CurrentProgProcess;

int execute (char *name, char *args, char *dir, int output, int hidden, int wait, 
	char *buffer, int size)
/**** execute
	Call an external program, return 0, if there was no error.
****/
{	
	if (output && !wait && CurrentProgProcess) execkill();

	String line("",MAXLINE);
	if (args) sprintf(line,"\"%s\" %s",name,args);
	else sprintf(line,"\"%s\"",name);

	STARTUPINFO si; // structure to start a process
	PROCESS_INFORMATION pi; // structure to get back process information
	
	ZeroMemory( &si, sizeof(si) );
	si.cb = sizeof(si);
	
	ZeroMemory( &pi, sizeof(pi) );

	SECURITY_ATTRIBUTES saAttr; 
	saAttr.nLength = sizeof(SECURITY_ATTRIBUTES); 
	saAttr.bInheritHandle = TRUE; 
	saAttr.lpSecurityDescriptor = NULL; 

	if (output)
	{
		if (!CreatePipe(&progeulerin,&progout,&saAttr,MAXLINE))
		{	
			DumpWarning("Could not pipe from\n%s","Euler",line);
			error=1; return 0;
		}
		if (!CreatePipe(&progin,&progeulerout,&saAttr,MAXLINE))
		{	
			DumpWarning("Could not pipe to\n%s","Euler",line);
			error=1; return 0;
		}
		si.hStdError=progout;
		si.hStdOutput=progout;
		si.hStdInput=progin;
		si.dwFlags |= STARTF_USESTDHANDLES;
	}

	if (askexec && !allowcommandonce)
	{
		String ask("");
		ask.cat("Euler wants to execute the command\n\n");
		ask.cat(line);
		if (dir!=0 && *dir!=0)
		{
			ask.cat("\n\nin directory\n\n");
			ask.cat(dir);
		}
		ask.cat("\n\nAllow this command?");
		int res=askuser(ask);
		if (res==2)
		{
			print("Command was not allowed!\n");
			error=1; return 1;
		}
		if (res==ID_Always) allowcommandonce=1;
	}

	if (!CreateProcess(0,line,0,0,TRUE,hidden?CREATE_NO_WINDOW:0,0,dir,&si,&pi))
	{
		char *pcmd=searchcmd(name);
		if (!pcmd)
		{
			error=1;
			DumpWarning("Could not find\n%s","Euler",name);
			return 1;
		}
		if (args) sprintf(line,"\"%s\" %s",pcmd,args);
		else sprintf(line,"\"%s\"",pcmd);
		if (!CreateProcess(0,line,0,0,TRUE,hidden?CREATE_NO_WINDOW:0,0,*dir?dir:0,&si,&pi))
		{
			error=1;
			DumpWarning("Could not call\n%s","Euler",line);
			return 1;
		}
	}

	CurrentProgProcess=pi.hProcess;
	DWORD ex=0;

	if (wait) 
	{
		setstatus("Waiting for process, press Esc to exit.");
		while (true)
		{	
			if (!WaitForSingleObject(pi.hProcess,500)) break;
			if (test_key()) break;
		}
		TerminateProcess(CurrentProgProcess,0);
		CurrentProgProcess=0;
		setstatus("");
	}

	if (output && wait)
	{
		execread(buffer,size);
	}

	if (wait) 
	{
		GetExitCodeProcess(pi.hProcess,&ex);
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
	}

	return ex;
}

int execread (char *buffer, int size)
{
	DWORD l=0;
	DWORD la,ll;
	int res=PeekNamedPipe(progeulerin,buffer,size-1,&l,&la,&ll);
	if (l>0) res=ReadFile(progeulerin,buffer,size-2,&l,0);
	buffer[l]=0;
	return res;
}

int execwrite (char *s, int nl)
{
	DWORD l=0;
	if (nl)
	{
		WriteFile(progeulerout,s,(int)strlen(s),&l,0);
		return WriteFile(progeulerout,"\n",(int)strlen("\n"),&l,0);
	}
	else
	{
		return WriteFile(progeulerout,s,(int)strlen(s),&l,0);
	}
}

void execkill ()
{
	if (CurrentProgProcess) TerminateProcess(CurrentProgProcess,0);
	CurrentProgProcess=0;
}

// ***** help button for various dialogs *****

void browse (char *file);

int HelpButton::command (LPARAM p)
{
	browse(S);
	return 1;
}

// Exit, after asking the user.
int exit ()
{  
	if (!wantquit)
	{	
		if (text->changed() && askconfirmations)
		{	
			if (!waiting) computation.suspend();
			int answer=QuestionAbort("Save Notebook before quitting?",
				"Euler",textwindow);
			if (!waiting) computation.resume();
			if (answer==Answers::yes) 
				if (!dosave()) return 0;
			if (answer==Answers::abort) return 0;
		}
	}
	textwindow.quit();
	return 1;
}

void doexit ()
{	exit();
}

// Set the name for the title of the window
void setwindowname ()
{	
	NotebookName.copy(FileName);
	NotebookName.copy(NotebookName.filename());
	*NotebookName.extension()=0;
	String Titlename(NotebookName);
	if (Titlename.length()==0) Titlename.copy("New Notebook");
	String NewWindowTitle("",512);
#ifdef WIN64
	if (second) sprintf(NewWindowTitle,"*** EMT Window x64 **** (%s)",Titlename.text());
	else sprintf(NewWindowTitle,"EMT x64 (%s)",Titlename.text());
#else
	if (second) sprintf(NewWindowTitle,"*** EMT Window **** (%s)",Titlename.text());
	else sprintf(NewWindowTitle,"EMT (%s)",Titlename.text());
#endif
	if (text->changed()) NewWindowTitle.cat(" (changed)");
	WindowTitle.copy(NewWindowTitle);
	textwindow.title(WindowTitle);
}

void donew ()
{   
	if (!editing || text->type()!=TextLine::prompt) return;
	if (text->changed() &&
		(!askconfirmations || Question("Delete Notebook?","Euler",
			textwindow)!=Answers::yes)) return;
	clear_notebook();
}

void clear_notebook ()
{	
	textwindow.stophelptimer();
	text->clear();
	text->newprompt();
	NotebookName.copy("");
	sprintf(WindowTitle,"Euler (%s)",NotebookName.text());
	setwindowname();
    text->changed(0);
	matlab=0;
	gclear();
}

void addrecent(char *s);
void dorestart(int ask);

char *geteulerfiles ()
{	
	static String Name;
	if (eulerfiles.empty())
	{	Name.copy(getownfiles());
		Name.cat("Euler Files\\");
		if (!exists(Name.text())) Name.copy(getownfiles());
	}
	else Name.copy(eulerfiles);
	return Name.text();
}

char * getuserhomedir ()
{	
	return getuserhome();
}

char * getusereulerdir ()
{	
	static String s;
	s.copy(getuserhome());
	s.cat("Euler\\");
	if (!exists(s)) _mkdir(s);
	if (!exists(s)) s.copy(getuserhome());
	return s;
}

char * getuserdir ()
{	return geteulerfiles();
}

extern String slatexbin;
int generatepdf=0;

int findexe (char *path, char *exe, char *exepath);

void dogeneratelatexcontinue (int res)
{
	if (!res) return;

	String File(FileName);
	File.extension(".tex");
	int oldfold=foldallmultilines;
	if (!respectfoldinglatex) foldallmultilines=0;
	text->exportlatex(File);
	foldallmultilines=oldfold;

	if (!generatepdf || disablelatex || generatelatexfileonly) return;

	STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si,sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi,sizeof(pi));

	String command("",MAXLINE);

	char pcmd[MAXLINE];
	if (!findexe(slatexbin,"pdflatex",pcmd))
	{
		DumpWarning("Program pdflatex could not be found.\nPlease configure Latex in the Menu!","Euler");
		return;
	}
	sprintf(command,"\"%s\" %s\"%s\"",
		pcmd,latexsilent?"-interaction=nonstopmode ":"",File.filename());

	if (!CreateProcess(0,command.text(),
		0,0,TRUE,latexsilent?CREATE_NO_WINDOW:0,0,0,&si,&pi))
	{
		char ws[MAXLINE+255];
		sprintf(ws,"Could not start the Latex process!\nCommand Line was:\n%s\n%s",
			command.text(),getsystemerror());
		Warning(ws,"Euler");
	}
	if (WaitForSingleObject(pi.hProcess,INFINITE))
	{
		if (!linux)
		{
			DumpWarning(
				"Waiting for the latex process failed!\n"
				"%s\n"
				"Please retry.",
				"Euler",command.text());
			CurrentProcess=0;
			return;
		}
		else
		{
			File.copy(FileName);
			File.extension(".log");
			int tries=0;
			while (!exists(File) && tries<100) { tries++; Sleep(200); }
		}
	}

	File.copy(FileName);
	File.extension(".aux");
	remove(File.text());
	File.extension(".log");
	remove(File.text());
	File.extension(".toc");
	remove(File.text());
	File.extension(".out");
	remove(File.text());
	File.extension(".nav");
	remove(File.text());
	File.extension(".snm");
	remove(File.text());

	if (!openexportedpdf) return;

	// try to show the PDF in the default viewer.
	File.extension(".pdf");
	if (!exists(File.text())) return;
	TCHAR szApp[MAX_PATH];
	DWORD cch = (sizeof(szApp) / sizeof(szApp[0]));
	if (AssocQueryString(0, ASSOCSTR_EXECUTABLE, ".pdf", NULL, szApp, &cch)!=S_OK) return;
	sprintf(command,"\"%s\" \"%s\"",szApp,File.text());	
	if (!CreateProcess(0,command.text(),0,0,TRUE,0,0,0,&si,&pi)) return;

}

void dogeneratepdf ()
	// save, generate Latex, and compile for PDF with pdflatex
{
	if (!editing || nojump || text->type()!=TextLine::prompt) return;

	Dialog d(textwindow,IDD_ExportPDF);

	CheckItem openpdf(ID_OpenPDF,d,openexportedpdf);
	CheckItem onlylatex(ID_OnlyLatex,d,generatelatexfileonly);
	CheckItem fold(ID_RespectFolding,d,respectfoldinglatex);

	HelpButton help(d,"documentation/export.html");

	d.carryout();
	
	if (d.result()==Dialog::ok)
	{
		openexportedpdf=openpdf;
		generatelatexfileonly=onlylatex;
		respectfoldinglatex=fold;
		generatepdf=1;
		savethread(dosave,dogeneratelatexcontinue);
	}
}

void doexporthtmlcontinue (int res);
void doexportsvg ();
// Save an export HTML
void doexporthtml ()
{	
	if (!editing || nojump || text->type()!=TextLine::prompt) return;

	Dialog d(textwindow,IDD_Export);

	CheckItem openhtml(ID_OpenHtml,d,openexportedhtml);
	CheckItem largeimages(ID_LargeImages,d,uselargeimagesforhtml);
	CheckItem utf8(ID_UTF8,d,htmlutf);
	CheckItem xml(ID_XML,d,generatexhtml);
	CheckItem mathjax(ID_MathJax,d,exportlatexasmathjax);
	CheckItem svg(ID_SVG,d,createsvg);
	CheckItem fold(ID_RespectFolding,d,respectfolding);
	CheckItem fnoreformat(ID_DoNotReformatComments,d,noreformat);

	HelpButton help(d,"documentation/export.html");

	d.carryout();
	
	if (d.result()==Dialog::ok)
	{
		openexportedhtml=openhtml;
		uselargeimagesforhtml=largeimages;
		htmlutf=utf8;
		generatexhtml=xml;
		exportlatexasmathjax=mathjax;
		createsvg=svg;
		respectfolding=fold;
		noreformat=fnoreformat;
		if (svg) doexportsvg();
		else savethread(dosave,doexporthtmlcontinue);
	}
}

void saveandexporthtml ()
{
	savethread(saveit,doexporthtmlcontinue);
}

void exporthtml ()
{
	savethread(dosave,doexporthtmlcontinue);
}

void doviewhtml ();
void doexporthtmlcontinue (int res)
{
	if (!res) return;
	String File(FileName);
	File.extension(".html");
	int fold=foldallmultilines;
	if (!respectfolding) foldallmultilines=0;
	text->exporthtml(File);
	foldallmultilines=fold;
    text->changed(0);
	if (openexportedhtml) doviewhtml();
}

void doviewhtml ()
{	
	if (!editing || nojump || text->type()!=TextLine::prompt) return;
	if (!dosave()) return;
	String File("file://");
	File.cat(FileName);
	File.extension(".html");
	browse(File);
}

/*
Convert a textline to HTML for HTML export.
Look for "See: " and add a link to the related function in the index.
Replace <, > and & with proper HTML tags.
*/
char *htmltext (char *p)
{	
	static char out[MAXLINE];
	char *q=out;
	if ((strstarts(p,"// See: ") || strstarts(p,"// see: "))  && !strcontains(p,","))
	{	
		p+=strlen("// See: ");
		sprintf(out,"<a href=\"%s.html\">%s</a>",p,p);
		return out;
	}	
	if (strncmp(p,"// http",strlen("// http"))==0)
	{	
		p+=strlen("// ");
		sprintf(out,"<a href=\"%s\">%s</a>",p,p);
		return out;
	}	
	while (*p!=0 && q-out<MAXLINE-20)
	{	switch (*p)
		{	case '>' : p++; *q++='&'; *q++='g'; *q++='t'; *q++=';'; break;
			case '<' : p++; *q++='&'; *q++='l'; *q++='t'; *q++=';'; break;
			case '&' : p++; *q++='&'; *q++='a'; *q++='m'; *q++='p'; *q++=';'; break;
			default : *q++=*p++;
		}
	}
	*q=0;
	return out;
}

void fs (char *s, FILE *out);
void fshtml (char *s, FILE *out);

void docreateehtml ()
{
	if (!editing || nojump) return;
	String name(loadfile.select());
	if (!*name) return;
	String outname(name);
	outname.cat(".html");
	FILE *in=fopen(name,"r");
	if (!in)
	{
		DumpWarning("Could not open\n%s","Euler",name.text());
		return;
	}
	FILE *out=fopen(outname,"w");
	if (!out)
	{
		DumpWarning("Could not open\n%s","Euler",outname.text());
		return;
	}

	String fname(name);
	fname.extension("");
	name.copy(fname.filename());
	String title(fname.filename());

	String path(fname);
	path.stripfilename();
	path.cat("\\euler.css");
	int externalcss=exists(path.text());

	path.copy(fname);
	path.stripfilename();
	path.cat("\\pattern.html");
	FILE *pin;
	pin=fopen(path.text(),"r");

	char pline[MAXLINE];
	if (pin)
	{	while (pin)
		{	if (!fgets(pline,MAXLINE-2,pin)) break;
			if (*pline=='#') break;
			fputs(pline,out);
		}
	}
	else
	{
		fputs("<!DOCTYPE html>\n",out);
		fputs("\n",out);
		fputs("<head>\n",out);
		fputs("<title>",out); fputs(title,out); fputs("</title>\n",out);
		if (externalcss)
		{	
			String path(fname);
			path.stripfilename();
			path.cat("\\euler.css");
			if (!exists(path.text()))
			{	Warning("euler.css could not be found!","Euler");
			}
			fputs("<LINK REL=\"stylesheet\" TYPE=\"text/css\" HREF=\"euler.css\">\n",out);
		}
		else
		{	
			fputs("<style type=\"text/css\">\n",out);
			fputs("body { width : 800px; font-family: arial, sans-serif; font-size: 10pt; margin: 20px; }\n",out);
			fputs("pre { font-family : \"Courier New\", monospace; background: #EEE; padding: 10px; }\n",out);
			fputs("pre.output { font-family : \"Courier New\", monospace; font-size : 10pt; margin-left: 20px; }\n",out);
			fputs("pre.udf { font-family : \"Courier New\", monospace; font-size : 10pt; color : #007; }\n",out);
			fputs("pre.prompt { font-family : \"Courier New\", monospace; font-size : 10pt; color : #700; }\n",out);
			fputs("pre.comment { font-family : \"Courier New\", monospace; font-size : 10pt; color : #060; background: none; margin-left: 20px; }\n",out);
			fputs("h1.title { font-family : arial, sans-serif; text-align : right; font-size : 240%; padding-bottom: 10px; border-bottom: 2px solid #e9b06e; }\n",out);
			fputs("h1.comment { font-family : arial, sans-serif; text-align : right; font-size : 160%; color : #000; border-bottom: 2px solid #e9b06e; }\n",out);
			fputs("img.euler { margin-left:20px; }\n",out);
			fputs("p.image { text-align:center; }\n",out);
			fputs("</style>\n",out);
		}
		fputs("</head>\n",out);
		fputs("\n",out);
		fputs("<body>\n",out);
	}

	int firstline=1;
	int eof=0;

	char line[1024];
	eof=!fgets(line,1024,in);

	while(1)
	{
		if (eof) break;

		if (firstline && strncmp(line,"// ",3)==0)
		{
			fputs("<H1>\n",out);
			fshtml(strncmp(line,"// * ",5)==0?line+5:line+3,out);
			fputs("</H1>\n",out);
			firstline=0;
			eof=!fgets(line,1022,in);
			continue;
		}
		firstline=0;

		if (strncmp(line,"// * ",5)==0)
		{
			fputs("<h2>\n",out);
			fshtml(line+5,out);
			fputs("</h2>",out);
			eof=!fgets(line,1022,in);
			continue;
		}

		if (strncmp(line,"// >",4)==0)
		{
			fputs("<pre class=\"function\">\n",out);
			while(1)
			{
				fshtml(line+3,out);
				if (!fgets(line,1022,in)) { eof=1; break; }
				if (strncmp(line,"// >",4)!=0) break;
			}
			fputs("</pre>\n",out);	
			continue;
		}

		if (strncmp(line,"// ",3)==0)
		{
			fputs("<p>\n",out);
			while(1)
			{
				fshtml(line+3,out);
				if (!fgets(line,1022,in)) { eof=1; break; }
				if (strncmp(line,"// ",3)!=0) break;
			}
			fputs("</p>\n",out);	
			continue;
		}

		if (strncmp(line,"comment",7)==0)
		{
			if (!fgets(line,1022,in)) break;
			fputs("<p>\n",out);
			while(1)
			{
				if (line[0]==0 || line[0]==10 || line[0]==13)
				{
					fputs("</p>\n",out);
					fputs("<p>\n",out);
				}
				else fshtml(line,out);
				if (!fgets(line,1022,in)) { eof=1; break; }
				if (strncmp(line,"endcomment",10)==0) break;
			}
			fputs("</p>\n",out);	
			if (eof) break;
			if (!fgets(line,1022,in)) break;
			continue;
		}

		if (strstr(line,":="))
		{
			fputs("<pre class=\"function\">\n",out);
			fshtml(line,out);
			fputs("</pre>\n",out);
			if (!fgets(line,1022,in)) break;
			continue;
		}

		if (strstarts(line,"function "))
		{
			fputs("<pre class=\"function\">\n",out);
			fshtml(line,out);
			int havecomment=0;
			while(1)
			{
				if (eof) break;
				if (!fgets(line,1022,in)) { eof=1; break; }
				if (line[0]==0 || line[0]==10 || line[0]==13) break;
				if (strncmp(line,"endfunction",strlen("endfunction"))==0) break;
				if (strncmp(line,"function",strlen("function"))==0) break;
				if (!havecomment && strncmp(line,"##",2)==0)
				{
					fputs("\n ",out);
					fshtml(line+2,out);
					while (1)
					{
						if (!fgets(line,1022,in)) { eof=1; break; }
						if (strncmp(line,"##",2)==0)
						{
							fputs(" ",out);
							fshtml(line+2,out);
						}
						else break;
					}
					havecomment=1;
				}
			}
			fputs("</pre>\n",out);
			continue;
		}

		if (!fgets(line,1024,in)) break;
	}

	if (pin)
	{	while (pin)
		{	if (!fgets(pline,1022,pin)) break;
			fputs(pline,out);
		}
		fclose(pin);
	}
	else
	{	fputs("</body>\n",out);
		fputs("</html>\n",out);
	}

	fclose(out);
	fclose(in);
}

void doviewmarkdown()
{
	if (!editing || nojump || text->type() != TextLine::prompt) return;
	if (!dosave()) return;
	String File("file://");
	File.cat(FileName);
	File.extension(".md");
	browse(File);
}

void doexportmarkdowncontinue(int res)
{
	if (!res) return;
	String File(FileName);
	File.extension(".md");
	int fold = foldallmultilines;
	if (!respectfolding) foldallmultilines = 0;
	text->exportmarkdown(File);
	foldallmultilines = fold;
	text->changed(0);
	if (openexportedhtml) doviewmarkdown();
}

void doexportmarkdown()
{
	if (!editing || nojump || text->type() != TextLine::prompt) return;

	Dialog d(textwindow, IDD_MarkdownExport);

	CheckItem openhtml(ID_OpenHtml, d, openexportedhtml);
	CheckItem largeimages(ID_LargeImages, d, uselargeimagesforhtml);
	CheckItem utf8(ID_UTF8, d, htmlutf);
	CheckItem fold(ID_RespectFolding, d, respectfolding);
	CheckItem fnoreformat(ID_DoNotReformatComments, d, noreformat);

	HelpButton help(d, "documentation/export.html");

	d.carryout();

	if (d.result() == Dialog::ok)
	{
		openexportedhtml = openhtml;
		uselargeimagesforhtml = largeimages;
		htmlutf = utf8;
		respectfolding = fold;
		noreformat = fnoreformat;
		savethread(dosave, doexportmarkdowncontinue);
	}

}

// Edit the comment of the current command.
void docomment ()
{   
	if (!editing || nojump || text->type()!=TextLine::prompt) return;
	text->comment();
	if (spellcheck)
	{
		text->spellcheck();
		text->redraw();
	}
}

// Update the comment of the current command.
void doupdatecomment ()
{   
	if (!editing || nojump || text->type()!=TextLine::prompt) return;
	text->updatecomment();
	text->execute();
}

String version("",32);

void getversion ()
{
	String name;
	name.copy(getstartdir());
	name.cat("version.txt");
	FILE* f=fopen(name.text(),"r");
	if (!f) return;
	fgets(version.text(),32,f);
	fclose(f);
}

void openinbrowser(char* site)
{
	char sv[1024];

	STARTUPINFO si; // structure to start a process
	PROCESS_INFORMATION pi; // structure to get back process information

	sprintf(sv, "cmd /c start %s",site);
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);

	ZeroMemory(&pi, sizeof(pi));

	if (!CreateProcess(0, sv, 0, 0, 0, CREATE_NO_WINDOW, 0, 0, &si, &pi))
	{
		char ws[MAXLINE + 255];
		sprintf(ws, "Could not open the browser!\nTry editing the browser settings.\nCommand Line was:\n%s", sv);
		Warning(ws, "Euler");
		return;
	}
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

}

// Call the "About Euler" dialog.
void doabout ()
{   
	char sv[1024];
#ifdef WIN64
	sprintf(sv,"Euler Math Toolbox x64 for Windows\n"
		"Copyright Rene Grothmann\n"
		"GPL - Open Source\n\n"
		"This is version %s\n\n"
		"www.euler-math-toolbox.de",
		version.text());
#else
	sprintf(sv,"Euler Math Toolbox for Windows\n"
		"Copyright Rene Grothmann\n"
		"GPL - Open Source\n\n"
		"This is version %s\n\n"
		"For updates and contact information\n"
		"visit the Homepage at\n"
		"www.euler-math-toolbox.de",
		version.text());
#endif
	Dialog dr(textwindow,IDD_About);
	TextItem v(ID_Version,dr,sv);
	dr.carryout();
	if (dr.result()==Dialog::ok)
	{	
		openinbrowser("http://www.euler-math-toolbox.de");
	}
}

class DefaultSizesButton : public ButtonItem
{   
	LongItem Stack,Graphics;
	public :
	DefaultSizesButton (int id, Dialog &d,
		LongItem &stack, LongItem &graphics)
		: ButtonItem(id,d),Stack(stack),Graphics(graphics)
	{}
	int command (LPARAM p)
	{	
#ifdef WIN64
		Stack.set(1024);
		Graphics.set(256);
#else
		Stack.set(512);
		Graphics.set(128);
#endif
		return 1;
	}
};

void dosetsizes ()
{   
	Dialog d(textwindow,IDD_Sizes);
	LongItem stack(ID_StackSize,d,stacksize);
	LongItem graphics(ID_GraphicsSize,d,graphicssize);
	DefaultSizesButton button(ID_Default,d,stack,graphics);
	HelpButton help(d,"reference/overview.html#Program%C2%A0Options");

	d.carryout();
	
	if (d.result()==Dialog::ok)
	{	
		stacksize=stack;
		if (stacksize<128) stacksize=128;
#ifndef WIN64
		if (stacksize>1024) stacksize=1024;
#endif
		graphicssize=graphics;
		if (graphicssize<32) graphicssize=32;
#ifndef WIN64
		if (graphicssize>256) graphicssize=256;
#endif
	}
	else return;
}

void docodepage ()
{
	Dialog d(textwindow, IDD_Codepage);
	LongItem stack(ID_Codepage, d, CODE_PAGE);
	HelpButton help(d, "reference/overview.html#Program%C2%A0Options");

	d.carryout();

	if (d.result() == Dialog::ok)
	{
		CODE_PAGE = stack;
	}
	else return;
}

void doload ()
{   
	if (!editing || nojump) return;
	String name(loadfile.select());
	if (!*name) return;
	String dir(name);
	dir.stripfilename();
	cd(dir);
	char s[256];
	sprintf(s,"load \"%s\";",name.text());
	text->execute(s);
}

void clear_usermenu ();
void closelibs ();

extern int pythonmode;

void dorestart (int ask)
{   
	if (!editing || nojump) return;
	if (ask && askconfirmations && 
		Question("Really restart?","Euler",textwindow)==Answers::no) return;
	static char *s="restart";
	end_maxima();
	py_exit();
	pythonmode=0;
	maximamode=0;
	allowcommandonce=0;
	allowdllonce=0;
	allowpythononce=0;
	textwindow.stopupdatetimer();
	clear_usermenu();
	FileName.copy("");
	closelibs();
	exit_globalvars();
	clearaliases();
	text->execute(s);
}

void dorestart ()
{	
	dorestart(1);
}

void doinsertimage ()
{	
	if (!editing || nojump) return;
	if (text->cursorline()->length()>1)
	{	
		text->insertline();
		text->cursorline()->type(TextLine::prompt);
	}
	text->cursorline()->copy(">insimg(25,\"\");");
	text->execute();
	text->unmarkall();
}

void domaximamode ()
{	
	if (!editing || nojump) return;
	if (text->cursorline()->length()>1)
	{	text->insertline();
		text->cursorline()->type(TextLine::prompt);
	}
	if (maximamode) text->cursorline()->copy(">maximamode off");
	else text->cursorline()->copy(">maximamode on");
	text->execute();
}

void domaximamodedirect ()
{	
	if (!editing || nojump) return;
	if (text->cursorline()->length()>1)
	{	text->insertline();
		text->cursorline()->type(TextLine::prompt);
	}
	if (maximamode) text->cursorline()->copy(">maximamode off");
	else text->cursorline()->copy(">maximamode direct");
	text->execute();
}

void updateresults ()
{	
	if (!editing || nojump || text->type()!=TextLine::prompt) return;
	runcommands=1000;
	skipbreaks=0;
	TextLine *l=text->cursorline();
	if (text->isbreak(l))
	{
		text->lineup(); 
		l=text->cursorline();
	}
	while (true)
	{
		if (text->isAfterBreak(l)) break;
		text->lineup();
		if (l==text->cursorline()) break;
		l=text->cursorline();
	}
	computation.resume();
}

// Run all subsequent commands
void doruncommands ()
{	
	if (!editing || nojump || text->type()!=TextLine::prompt) return;
	runcommands=1000;
	skipbreaks=1;
	updatecomments=0;
	generatesvg=0;
	computation.resume();
}

extern int svgnumber;

void doexportsvg ()
	// Run all subsequent commands, and setup for SVG export when the run finishes.
{	
	if (!editing || nojump || text->type()!=TextLine::prompt) return;

	int res=0;
	if (*NotebookName==0) res=dosaveas();
	else res=text->save(FileName);
    text->changed(0);
	if (!res) return;

	text->gototextstart();
	runcommands=1000;
	skipbreaks=1;
	updatecomments=0;
	generatesvg=1;
	svgnumber=1;
	computation.resume();
}

void doupdatecomments ()
	// Run all subsequent commands
{	
	if (!editing || nojump || text->type()!=TextLine::prompt) return;
	text->updatecomment();
	runcommands=1000;
	skipbreaks=1;
	updatecomments=1;
	computation.resume();
}

void dodeletecommand ()
{	
	if (!editing || nojump) return;
	text->deletecommand();
}

void doinsertcommand ()
{	
	if (!editing || nojump) return;
	text->insertcommand();
}

void doundodelete ()
{	
	if (!editing || nojump) return;
	text->undodelete();
}

void doundo ()
{	
	if (!editing || nojump || text->type()!=TextLine::prompt) return;
	text->undo();
	textwindow.update();
}

void doredo ()
{	
	if (!editing || nojump || text->type()!=TextLine::prompt) return;
	text->redo();
	textwindow.update();
}

void doselectall ()
{	
	if (!editing || nojump) return;
	text->selectall();
}

void dodeleteoutput ()
{	
	if (!editing || nojump) return;
	text->deleteoutput();
}

void dodeletealloutput ()
{   
	if (!editing || nojump) return;
	text->selectall();
	text->deleteoutput();
}

void docopytext ()
{	
	text->copytext();
}

void docuttext ()
{	
	if (!editing) return;
	text->copytext();
	text->deletemark();
}

void docopycommands ()
{	
	text->copycommands();
}

void docopyformatted ()
{	
	text->copyformatted();
}

void dopastecommands ()
{	
	text->pastecommands();
}

void dopasteascommands ()
{	
	text->pasteascommands();
}

// **** Print the Graphics ****

PrinterPS *usedprinter;

int printit ()
{   
	PrinterPS &printer=*usedprinter;
	printer.start();
	int w,h,xm,ym,y,pw,ph,o;
	pw=printer.width();
	ph=printer.height();
	o=(int)(pw*0.1);
	w=pw-2*o;
	h=(int)((double)w*graphicswindow->bitmapheight()/graphicswindow->bitmapwidth());
	xm=pw/2;
	ym=h/2+o;
	if (ym+h/2>ph-o)
	{	h=ph-2*o;
		w=(int)((double)h*graphicswindow->bitmapwidth()/graphicswindow->bitmapheight());
		ym=ph/2;
		xm=w/2+o;
	}
	printer.set(xm-w/2,ym-h/2,w,h);
	Font pfont(GraphicsFontName,
		max(h,w)/gscreenlines,boldfont?Font::bold:Font::normal);
	printer.font(pfont);
	Font pufont(GraphicsFontName,
		max(w,h)/gscreenlines,boldfont?Font::bold:Font::normal,0,900);
	printer.rememberfont(1,pufont);
	Font pdfont(GraphicsFontName,
		max(w,h)/gscreenlines,boldfont?Font::bold:Font::normal,0,2700);
	printer.rememberfont(2,pdfont);

	critical.enter();
	int al=antialiasgraphics;
	antialiasgraphics=0;
	set_styles(antialiasgraphics,linewidth(printer.width(),1,!fatterlines)/2);
	meta->replay(&printer,0);
	antialiasgraphics=al;
	setstyles();
	critical.leave();
	
	printer.textcolor(Color::text());
	char *p=(char *)PrintText;
	if (*p)
	{	y=ym+h/2+o;
		while (1)
		{   printer.set(o,y,pw-2*o,ph-o-y);
			p=printer.multiline(p,0,0,pw-2*o,ph-o-y);
			if (*p==0) break;
			printer.formfeed();
			y=o;
		}
	}
	printer.formfeed();
	delete usedprinter;
	return 0;
}

Thread printthread(printit);

String PrinterString("");

void doprint ()
{	
	if (!editing || nojump) return;
	if (*Printer==0) Printer.getprinter();
	Dialog d(textwindow,IDD_Print);
	PrinterItem p(ID_Printer,d,Printer);
	MultilineItem dtext(ID_PrintText,d,PrintText);
	dtext.setfont(*courier);
	HelpButton help(d,"documentation/gui.html#Print");

	d.carryout();
	if (d.result()!=Dialog::ok) return;
	
	PrintText.copy(dtext);
	Printer.copy(p);
	PrinterString.copy(Printer);
	usedprinter=new PrinterPS("Euler",Printer);
	if (!usedprinter->handle())
	{   
		Warning("No Printer available!","Euler");
		delete usedprinter;
		return;
	}
	printthread.start();
}

void doclearinput ()
{	
	text->getWindow()->key(Keycode::down|Keycode::virtualkey,VK_CONTROL,VK_BACK);
}

void doescape ()
{	
	text->getWindow()->key(Keycode::down|Keycode::charkey,27,27);
}

void donextinput ()
{	
	text->getWindow()->key(Keycode::down|Keycode::virtualkey,VK_CONTROL,VK_DOWN);
}

void dopreviousinput ()
{	
	text->getWindow()->key(Keycode::down|Keycode::virtualkey,VK_CONTROL,VK_UP);
}

String sbrowserstring("",MAXLINE),sbrowserdir("",MAXLINE);

void replace (char *p, char a, char b)
{
	while (*p)
	{
		if (*p==a) *p=b;
		p++;
	}
}

void browse (char *s)
{		
	char line[MAXLINE];

	TCHAR szApp[MAX_PATH];
	if (sbrowserstring.length()>0) 
	{
		strcpy(szApp,(char *)sbrowserstring);
	}
	else
	{	
		DWORD cch = (sizeof(szApp) / sizeof(szApp[0]));
		if (AssocQueryString(0, ASSOCSTR_EXECUTABLE, TEXT("http"), NULL, szApp, &cch)!=S_OK)
		{
			Warning("Could not find the default browser.\nPlease set it in the program settings.","Euler");
			return;
		}
	}

	if (strncmp(s,"http",4)==0)
	{
		sprintf(line,"\"%s\" \"%s\"",szApp,s);
	}
	else if (strncmp(s,"file",4)==0)
	{
		sprintf(line,"\"%s\" \"%s\"",szApp,s);
	}
	else if (strstarts(s,"See: ") || strstarts(s,"see: "))
	{
		char path[1024];
		_getcwd(path,1024);
		String st(s+5);
		int n=st.find(" | ");
		if (n<0)
		{
			st.trim();
			if (!st.startsWith("http") && !st.startsWith("file") && 
				!st.contains("#") && !*(st.extension())) st.cat(".html");
		}
		else
		{
			st.substring(0,n);
			st.trim();
			if (!st.startsWith("http") && !st.startsWith("file") && 
				!*st.extension()) st.extension(".html");
		}
		if (!st.startsWith("http") && !st.startsWith("file"))
			sprintf(line,"\"%s\" \"file://%s/%s\"",szApp,path,st.text());
		else
			sprintf(line,"\"%s\" \"%s\"",szApp,st.text());
	}
	else if (sbrowserdir.length()>0)
	{
		if (sbrowserdir.startsWith("http"))
			sprintf(line,"\"%s\" \"%s/%s\"",szApp,sbrowserdir.text(),s);
		else
			sprintf(line,"\"%s\" \"file://%s/%s\"",szApp,sbrowserdir.text(),s);
	}
	else
	{
		sprintf(line,"\"%s\" \"file://%sdocs/%s\"",szApp,getstartdir(),s);
		replace(line,'\\','/');
	}

	STARTUPINFO si; // structure to start a process
	PROCESS_INFORMATION pi; // structure to get back process information
	
	// Now start browser process:
	ZeroMemory( &si, sizeof(si) );
	si.cb = sizeof(si);
	
	ZeroMemory( &pi, sizeof(pi) );

	if (!CreateProcess(0,line,0,0,0,CREATE_NO_WINDOW,0,0,&si,&pi))
	{
		char ws[MAXLINE+255];
		sprintf(ws,"Could not open the browser!\nTry editing the browser settings.\nCommand Line was:\n%s",line);
		Warning(ws,"Euler");
		return;
	}
	CloseHandle( pi.hProcess );
	CloseHandle( pi.hThread );
}

class DefaultButton : public ButtonItem
{	
	StringItem S,Dir;
	public :
	DefaultButton (int id, Dialog &d, StringItem &s, StringItem &dir) :
		ButtonItem(id,d),S(s),Dir(dir) {}
	int command (LPARAM p)
	{	
		S.set("");
		Dir.set("");
		return 1;
	}
};

class BrowseButton : public ButtonItem
{	StringItem S;
	public :
	BrowseButton (int id, Dialog &d, StringItem &s) :
		ButtonItem(id,d),S(s) {}
	int command (LPARAM p)
	{	
		setbrowser.setFile(S.text());
		setbrowser.setDir(S.text());
		char *s=setbrowser.select();
		if (s && *s) S.set(s);
		return 1;
	}
};

class BrowseDirButton : public ButtonItem
{	StringItem S;
	public :
	BrowseDirButton (int id, Dialog &d, StringItem &s) :
		ButtonItem(id,d),S(s) {}
	int command (LPARAM p)
	{	
		setbrowser.dir(S.text());
		char *s=setbrowser.selectdir();
		if (s && *s) S.set(s);
		return 1;
	}
};

void dosetbrowser ()
{
	char s[MAXLINE]="";
	char dir[MAXLINE]="";

	if (sbrowserstring.length()>0) strcpy(s,(char *)sbrowserstring);
	else
	{	
		DWORD cch = sizeof(s);
		AssocQueryString(0, ASSOCSTR_EXECUTABLE, TEXT("http"), NULL, s, &cch);
	}

	strcpy(dir,(char *)sbrowserdir);

	Dialog d(textwindow,IDD_SetBrowser);
	StringItem cs(ID_BrowserLine,d,s);
	StringItem cdir(ID_BrowserDir,d,dir);
	DefaultButton def(ID_DefaultButton,d,cs,cdir);
	BrowseButton browsebrowser(ID_BrowseBrowser,d,cs);
	BrowseDirButton browsedocumentation(ID_BrowseDocumentation,d,cdir);
	HelpButton help(d,"documentation/gui.html#Browser_Command");

	d.carryout();
	if (d.result()==Dialog::ok)
	{	
		sbrowserstring.copy((char *)cs);
		sbrowserdir.copy((char *)cdir);
	}
}

String slatexbin("",MAXLINE),slatexdir("",MAXLINE);

void dosetlatex ()
// same code as dosetbrowser with other strings
{
	char s[MAXLINE]="";
	char dir[MAXLINE]="";

	if (slatexbin.length()>0) strcpy(s,(char *)slatexbin);
	if (slatexdir.length()>0) strcpy(dir,(char *)slatexdir);

	Dialog d(textwindow,IDD_SetLatex);
	StringItem cs(ID_LatexExecutable,d,s);
	StringItem cdir(ID_LatexWorkDir,d,dir);
	BrowseDirButton bs(ID_BrowseLatex,d,cs);
	BrowseDirButton bdir(ID_BrowseLatexWork,d,cdir);
	DefaultButton bdef(ID_DefaultButton,d,cs,cdir);
	HelpButton help(d,"documentation/installation.html#Latex");

	d.carryout();
	if (d.result()==Dialog::ok)
	{	
		slatexbin.copy((char *)cs); slatexbin.appendseparator();
		slatexdir.copy((char *)cdir); slatexdir.appendseparator();
	}
}

void dosearcheulersite ()
{	
	browse("search.html");
}

void doeulersite()
{
	openinbrowser("http://www.euler-math-toolbox.de");
}

void doversionlog ()
{
	browse("Programs/Changes.html");
}

void domaximareference ()
{	
	browse("reference/maximacore.html");
}

void doquicktips ()
{	
	browse("documentation/quicktips.html");
}

void doreference ()
{	browse("reference/index.html");
}

void doopendocumentation ()
{	browse("documentation.html");
}

void doedit();

void dofunction ()
{	if (!editing || nojump) return;
	if (text->cursorline()->length()>1)
	{	text->insertline();
		text->cursorline()->type(TextLine::prompt);
	}
	text->cursorline()->copy(">function f(x)");
	doedit();
	textwindow.update();
}

// **** Internal Editor Dialog ****

String editfile("",512);
class SaveButton : public ButtonItem
{	MultilineItem *E;
	public :
	SaveButton (int id, Dialog &d, MultilineItem &e) :
		ButtonItem(id,d),E(&e) {}
	virtual int command (LPARAM p);
};

int SaveButton::command (LPARAM p)
{	E->exit();
	String name(saveeditor.select(dialog()->handle()));
	if (name.empty()) return 1;
	FILE *out=fopen(name,"wb");
	if (!out)
	{	Warning("Could not open this file!","Save",textwindow);
		return 1;
	}
	fwrite(*E,1,strlen(*E),out);
	fclose(out);
	return 1;
}

class LoadButton : public ButtonItem
{	MultilineItem *E;
	public :
	LoadButton (int id, Dialog &d, MultilineItem &e) :
		ButtonItem(id,d),E(&e) {}
	virtual int command (LPARAM p);
};

FileSelector loadeditor(textwindow,"",FileSelector::load,
	"Load Editor File",".e","Euler Files\0*.e\0All Files\0*.*\0\0");

int editload (char *name, MultilineItem *E, int warning=1)
{	
	FILE *in=0;
	if (!warning) in=fopen(name,"r");
	else in=open_file_in_path(name,"r");
	if (!in && warning)
	{	
		Warning("Could not open this file!","Load",textwindow);
		return 1;
	}
	char s[MAXLINE];
	String l("",32000);
	while (!feof(in))
	{	
		if (!fgets(s,MAXLINE-2,in)) break;
		if (strlen(s)>0 && s[strlen(s)-1]=='\n') s[strlen(s)-1]=0;
		strcat(l,s);
		strcat(l,"\x0D\x0A");
		if ((int)strlen(l)>l.size()-MAXLINE-2)
		{	l.copy(l,l.size()+32000);
		}
	}
	E->set(l);
	fclose(in);
	return 1;
}

int LoadButton::command (LPARAM p)
{	E->exit();
	String name("");
	name.copy(loadeditor.select(dialog()->handle()));
	if (name.empty()) return 1;
	return editload (name,E);
}

int get_filename (char *next, char *name, int lmax=500)
{	int count=0;
	if (*next=='\"')
	{	next++;
		while (*next!='\"' && *next)
		{	*name++=*next++; count++;
			if (count>=lmax-1)
			{	Warning("Name too long!","load",textwindow);
				return 0;
			}
		}
		if (*next=='\"') next++;
	}
	else if (*next<=32 || *next==',' || *next==';' || isspace(*next))
	{   Warning("Name expected!","load",textwindow);
		*name=0; return 0;
	}
	else
	{	while (!(*next<=32 || *next==',' || *next==';' || isspace(*next)))
		{	
			*name++=*next++; count++;
			if (count>=lmax-1)
			{	Warning("Name too long!","load",textwindow);
				return 0;
			}
		}
	}
	*name=0;
	return 1;
}

void tabextendcopy (char *dest, char *source, int length, int maxdest);

char *extractline (char *q, char line[MAXLINE])
{	
	char h[MAXLINE];
	char *p=h;
	while (*q && *q!='\r' && *q!='\n' && p-line<MAXLINE) *p++=*q++;
	if (p-line==MAXLINE) return 0;
	*p=0;
	while (*q=='\r' || *q=='\n') q++;
	tabextendcopy(line,h,(int)strlen(h),MAXLINE);
	return q;
}

class EditDialog : public Dialog
{
public :
	EditDialog (Window &w, int id) : Dialog(w,id)
	{}
	void layout ()
	{
		positionelement(ID_OK,10,-1,-1,10);
		int w=elementwidth(ID_OK);
		positionelement(ID_CANCEL,w+30,-1,-1,10);
		positionelement(ID_Save,2*w+60,-1,-1,10);
		positionelement(ID_Load,3*w+70,-1,-1,10);
		positionelement(ID_Help,-1,10,-1,10);
		int h=elementheight(ID_OK);
		sizeelement(ID_Edit,10,10,10,h+20);
	}
};

int editx=200,edity=200,editw=400,edith=400;

void doedit ()
/*
Start the internal editor.
*/
{	
	if (!editing || nojump || text->type()!=TextLine::prompt) return;
	
	EditDialog d(textwindow,IDD_Edit);
	
	MultilineItem e(ID_Edit,d,"");
	e.setfont(*courier);
	SaveButton sb(ID_Save,d,e);
	LoadButton lb(ID_Load,d,e);
	StringItem title(15,d,"Internal Editor");
	HelpButton help(d,"documentation/gui.html#Internal_Editor");
	// load text into the editor
	int mode=0;
	editfile.copy(getusereulerdir());
	editfile.cat("EulerTemp.e");

	int linecount=0;
	TextLine *current = text->cursorline();
	if (strlen(text->currentline()+lefteditlimit)==0)
	// cursor is in an empty line, use default temporary file
	{	
		editload((char *)editfile,&e,0);
		String tt("Edit "); tt.cat(editfile);
		title.set(tt.text());
		mode=1;
	}
	else if (current->startsWith(">load "))
	// cursor line starts with a load, use that file
	{	
		char *q=current->text()+strlen(">load ");	
		if (!get_filename(q,editfile.text(),500)) return;
		if (*editfile.extension()==0) editfile.extension(".e");
		editload((char *)editfile,&e,0);
		String tt("Edit "); tt.cat(editfile);
		title.set(tt.text());
		mode=2;
	}
	else if (current->isFunctionLine() && 
		!(current->contains(":=") || current->contains("&=")
		|| current->contains("&&=")))
	// cursor line starts a function definition, edit that function
	{	
		text->removeoutput();
		String s(text->currentline()+lefteditlimit);
		TextLine *l=text->cursorline();
		while (l->next() && l->next()->type()==TextLine::udf)
		{	l=l->next();
			s.cat("\r\n");
			s.cat(l->text()+1);
		}
		e.set(s.text());
		title.set("Edit function definition");
		mode=3;
	}
	else
	// other cases, simple command lines
	{	
		TextLine *l=current;
		while (l) // go back and execute from there
		{	
			TextLine *lprev=l->prev();
			// goto the previous prompt (or 0, if there is none)
			while (lprev && lprev->type()!=TextLine::prompt)
			{	
				lprev=lprev->prev();
			}
			// stop if this is not part of a multiline
			if (!lprev || !lprev->endsWith("...") 
					|| lprev->nextcommand()->type()==TextLine::udf
					|| (lprev->isFunctionLine() && lprev->next()->type()==TextLine::udf)) 
						break;
			l=lprev;
		}
		if (l) text->setcursorline(l,0);
		String s(l->text()+1);
		linecount=1;
		while (l->endsWith("...") && l->nextprompt() &&
				!l->nextprompt()->isFunctionLine())
		{	
			l=l->nextprompt();
			s.cat("\r\n");
			s.cat(l->text()+1);
			linecount++;
		}
		e.set(s.text());
		title.set("Edit command line (Use ... for multi-line commands)");
		mode=4;
	}


	// open the dialog
	d.fitsize(wscreen,hscreen,editx,edity,editw,edith,400,400);
	d.carryout();
	d.getsize(editx,edity,editw,edith);
	
	// check results
	if (d.result()!=Dialog::ok && d.result()!=ID_Interpret) return;
	if (mode==1 || mode==2)
	{	
		FILE *out=fopen((char *)editfile,"wb");
		char s[600];
		sprintf(s,"Could not open %s !",(char *)editfile);
		if (!out)
		{	Warning(s,"Interpret",textwindow);
			return;
		}
		fwrite(e,1,strlen(e),out);
		fclose(out);
		if (mode==1) 
		{	sprintf(s,"load \"%s\"",(char *)editfile);
			text->set(s,1);
		}
	}
	else if (mode==3)
	{	
		function :
		char *q=e;
		char line[MAXLINE];
		char *p=extractline(q,line);
		if (!p)
		{	Warning("Line too long!","Editor",textwindow);
			return;
		}
		if (!strstarts(line,"function ") && !strstarts(line,"%+ function "))
		{	Warning("Function definition missing!","Editor",textwindow);
			return;
		}
		q=p;
		// set the function definition
		TextLine *l=text->cursorline();
		l->copy(">");
		l->cat(line);
		text->setcursorpos(1);
		// remove old function lines
		l=l->next();
		while (l)
		{	if (l->type()!=TextLine::udf) break;
			TextLine *h=l->next();
			delete l;
			l=h;
		}
		// insert edited function lines
		int count=0;
		l=text->cursorline();
		while (*q)
		{	p=extractline(q,line);
			if (!p)
			{	Warning("Line too long!","Editor",textwindow);
				return;
			}
			TextLine *lnew=new TextLine(text,l,l->next(),"$");
			lnew->cat(line);
			lnew->type(TextLine::udf);
			count++;
			l=lnew;
			q=p;
		}
		int multi=(l!=text->cursorline());
		if (multi && !text->cursorline()->endsWith("...")) 
			text->cursorline()->cat(" ...");
		if (multi && l->find("endfunction")==-1)
		{	TextLine *lnew=new TextLine(text,l,l->next(),"$");
			lnew->cat("endfunction");
			lnew->type(TextLine::udf);
		}
		textwindow.update();
	}
	else if (mode==4)
	{	
		char *q=e;
		char line[MAXLINE];
		char *p=extractline(q,line);
		if (strstarts(line,"function ") && 
		!(current->contains(":=") || current->contains("&=")
		|| current->contains("&&=")))
		{
			String sline(line);
			if (!(sline.contains(":=") || sline.contains(":=") || sline.contains(":=")))
				goto function;
		}
		if (!p)
		{	Warning("Line too long!","Editor",textwindow);
			return;
		}
		TextLine *l=text->cursorline();
		l->copy(">");
		l->cat(line);
		if (!l->endsWith("...") && *p) l->cat(" ...");
		text->setcursorpos(1);
		int count=0;
		q=p;
		while (*q)
		{	
			p=extractline(q,line);
			if (!p)
			{	Warning("Line too long!","Editor",textwindow);
				return;
			}
			count++;
			if (count<linecount)
			{	l=l->nextprompt();
				if (!l) return;
				l->copy(">");
				l->cat(line);
				if (!l->endsWith("...") && *p) l->cat(" ...");
			}
			else
			{	TextLine *lnew=new TextLine(text,l,l->next(),">");
				lnew->type(TextLine::prompt);
				lnew->cat(line);
				l=lnew;
				if (!lnew->endsWith("...") && *p) lnew->cat(" ...");
			}
			q=p;
		}
		textwindow.update();
	}
}

String externaleditor("javaw.exe");
String externalparameters("-jar je.jar");
String externalfile("");

class UseJEButton : public ButtonItem
{	StringItem E,P,F;
	public :
		UseJEButton (int id, Dialog &d, StringItem e, StringItem p, StringItem f) :
		ButtonItem(id,d),E(e),P(p),F(f) {}
	int command (LPARAM p)
	{	E.set("javaw"); F.set("");
		String ep;
		ep.copy("-jar \"");
		ep.cat(getstartdir());
		ep.cat("je.jar\"");
		P.set(ep.text());
		return 1;
	}	
};

void dosetupexternaleditor ()
{   Dialog d(textwindow,IDD_SetupExternalEditor);
	StringItem name(ID_Name,d,(char *)externaleditor);
	StringItem parameters(ID_Parameters,d,(char *)externalparameters);
	StringItem file(ID_File,d,(char *)externalfile);
	UseJEButton jeb(ID_UseJE,d,name,parameters,file);
	HelpButton help(d,"documentation/gui.html#External_Editor");
	d.carryout();
	if (d.result()==Dialog::cancel) return;
	externaleditor.copy((char *)(name));
	externalparameters.copy((char *)(parameters));
	externalfile.copy((char *)(file));
}

extern char foundfile[MAX_PATH];
extern int FindFilesRecursively (LPCTSTR lpFolder, LPCTSTR lpFilePattern);

void setmaximadefaults ()
{
	char s[MAX_PATH];
	strcpy(s,getstartdir());
	strcat(s,"maxima\\bin\\sbcl.exe");
	smaximacallstring.copy(s);
	strcpy(s,getstartdir());
	strcat(s,"maxima\\");
	smaximacalldir.copy(s);
}

class DefaultCallstringButton : public ButtonItem
{	StringItem S1,S2;
	public :
	DefaultCallstringButton (int id, Dialog &d, StringItem &s1, StringItem &s2) :
		ButtonItem(id,d),S1(s1),S2(s2) {}
	int command (LPARAM p)
	{	
		char s[MAXLINE];
		strcpy(s,getstartdir());
		strcat(s,"maxima\\bin\\sbcl.exe");
		S1.set(s); 
		strcpy(s,getstartdir());
		strcat(s,"maxima\\");
		S2.set(s);
		return 1;
	}
};

void doeditmaximacallstring ()
{	
	char s[MAXLINE];
	sprintf(s,"%s",smaximacallstring.text());
	char t[MAXLINE];
	sprintf(t,"%s",smaximacalldir.text());

	Dialog d(textwindow,IDD_EditMaximaCallString);
	StringItem cs(ID_MaximaCallString,d,s);
	StringItem cdir(ID_MaximaCallDir,d,t);
	BrowseButton bs(ID_BrowseMaxima,d,cs);
	BrowseDirButton bdir(ID_BrowseMaximaDir,d,cdir);
	DefaultCallstringButton def(ID_DefaultButton,d,cs,cdir);
	HelpButton help(d,"documentation/installation.html#Maxima");
	
	d.carryout();
	
	if (d.result()==Dialog::cancel) return;
	if (d.result()==Dialog::ok)
	{	
		smaximacallstring.copy((char *)cs);
		smaximacalldir.copy((char *)cdir);
		if (smaximacallstring.length()==0 && smaximacalldir.length()>0
			&& FindFilesRecursively(smaximacalldir.text(),"sbcl.exe"))
		{
			smaximacallstring.copy(foundfile);
		}
		if (smaximacallstring.length()==0 && smaximacalldir.length()>0
			&& FindFilesRecursively(smaximacalldir.text(),"maxima.exe"))
		{
			smaximacallstring.copy(foundfile);
		}
	}
}

String Search;

void dofind ()
{	if (!editing || nojump) return;
	Dialog d(textwindow,ID_FindDialog);
	StringItem cs(ID_SearchFor,d,Search.text());
	d.carryout();
	if (d.result()==Dialog::cancel) return;
	Search.copy((char *)cs);
	text->search((char *)cs);
}

void dofindnext ()
{	if (!editing || nojump) return;
	if (Search.length()==0) return;
	text->searchnext(Search.text());
}

char *search_file_in_path (char *filename, char *extension);

void doexternaledit ()
{	
	if (!editing || nojump) return;
	String command("\"");
	command.cat((char *)externaleditor);
	command.cat("\"");
	String h(externalfile,1000);
	if (strncmp(text->currentline()+lefteditlimit,
		"load ",strlen("load "))==0)
	// cursor line starts with a load, use that file
	{	
		char *q=text->currentline()+lefteditlimit+strlen("load ");
		get_filename(q,h.text(),500);
		if (!*h.extension() && !exists(h.text()))
		{	h.cat(".e");
		}
		char *s=search_file_in_path(h,"*.e");
		if (s) h=s;
	}
	else if (strncmp(text->currentline()+lefteditlimit,
		"tccompile ",strlen("tccompile "))==0)
	// cursor line starts with a load, use that file
	{	
		char *q=text->currentline()+lefteditlimit+strlen("tccompile ");
		get_filename(q,h.text(),500);
		if (!h.endsWith(".c") && !exists(h.text()))
		{	h.cat(".c");
		}
	}
	else if (h.length()==0)
	{	
		h.copy(getusereulerdir());
		h.cat("EulerTemp.e");
		if (strlen(text->currentline()+lefteditlimit)==0)
		{	
			char s[MAXLINE];
			sprintf(s,"load \"%s\"",(char *)h);
			text->set(s,1);
		}
	}
	String g("\""); g.cat(h); g.cat("\"");

	_spawnlp(_P_NOWAIT,
		(char *)externaleditor,
		(char *)command,
		(char *)externalparameters,
		(char *)g,
		NULL );
}

void doshowgraphics ()
{
	if (!editing) return;
	if (textmode) graphic_mode();
}

// **** Save Graphics as a bitmap ****

int idbits[4]={ID_1Bit,ID_4Bit,ID_8Bit,ID_24Bit};
int nbits[4]={1,4,8,24};
int savew=0,saveh=0,saveb=-1;
String Bitmapname;

class WindowSize : public ButtonItem
{   LongItem *W,*H;
	public :
	WindowSize (int id, Dialog &d, LongItem &w, LongItem &h) :
		ButtonItem(id,d),W(&w),H(&h) {}
	virtual int command (LPARAM l)
	{   W->set(graphicswindow->displaywidth());
		H->set(graphicswindow->displayheight());
		return 1;
	}
};

class Aspect : public ButtonItem
{   LongItem *W,*H;
	public :
	Aspect (int id, Dialog &d, LongItem &w, LongItem &h) :
		ButtonItem(id,d),W(&w),H(&h) {}
	virtual int command (LPARAM l)
	{   
		W->exit();
		int w=*W;
		H->set(rd(w/graphicswindow->aspect()));
		return 1;
	}
};

class ForPrint : public ButtonItem
{   LongItem *W,*H;
	CheckItem *AA;
	public :
	ForPrint (int id, Dialog &d, LongItem &w, LongItem &h, CheckItem &aa) :
		ButtonItem(id,d),W(&w),H(&h),AA(&aa) {}
	virtual int command (LPARAM l)
	{   
		W->exit();
		W->set(2000);
		int w=*W;
		H->set(rd(w/graphicswindow->aspect()));
		AA->set(false);
		return 1;
	}
};

void dosavepng ()
{	
	if (!editing || nojump) return;
	Dialog d(textwindow,IDD_SaveBitmap);
	if (savew==0) // set default global variables
	{	
		savew=graphicswindow->displaywidth();
		saveh=graphicswindow->displayheight();
	}
	LongItem w(ID_Width,d,savew);
	LongItem h(ID_Height,d,saveh);
	WindowSize ws(ID_WindowSize,d,w,h);
	HelpButton help(d,"documentation/gui.html#Graphics_Export");
	Aspect aspect(ID_Aspect,d,w,h);
	if (saveb<0) saveb=usecolors?2:0;
	CheckItem aa(ID_AntiAlias,d,savewithantialias);
	ForPrint forprint(ID_ForPrint,d,w,h,aa);

	// show the dialog
	d.carryout();
	if (d.result()!=Dialog::ok) return;

	Bitmapname.copy(savebitmap.select());
	if (Bitmapname.empty()) return;
	savepng(Bitmapname,w,h,aa);
}

BitmapPS* cropbitmap (BitmapPS *m)
{	
	if (croptop==0 && cropbottom==0 && cropleft==0 && cropright==0) return m;
	int left=rd(cropleft*m->width());
	int top=rd(croptop*m->height());
	int width=rd((1-cropleft-cropright)*m->width());
	int height=rd((1-cropbottom-croptop)*m->height());
	BitmapPS *mcrop=new BitmapPS(*graphicswindow,width,height);
	m->copy(*mcrop,-left,-top);
	delete m;
	return mcrop;
}

void savepng (char *filename, int w, int h, int aa)
{	
	if (w<10) w=graphicswindow->windowwidth();
	if (h<10) h=w*graphicswindow->windowheight()/graphicswindow->windowwidth();
	savewithantialias=(aa!=0);
	savew=w; saveh=h; saveb=24;
	Bitmapname.copy(filename);
	
	if (savew<10) savew=10;
	if (saveh<10) saveh=10;
	if (savewithantialias) { savew=savew*antialiasfactor; saveh=saveh*antialiasfactor; } // anti-aliasing on
	BitmapPS *m=new BitmapPS(*graphicswindow,savew,saveh);
	Font mfont(GraphicsFontName,
		max(savew,saveh)/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed);
	m->font(mfont);
	Font mufont(GraphicsFontName,
		max(savew,saveh)/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed,900);
	m->rememberfont(1,mufont);
	Font mdfont(GraphicsFontName,
		max(savew,saveh)/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed,2700);
	m->rememberfont(2,mdfont);
	
	// replay graphics
	critical.enter();
	int al=antialiasgraphics;
	antialiasgraphics=savewithantialias;
	set_styles(antialiasgraphics,linewidth(w,1,!fatterlines)/2);
	m->bar(0,0,savew,saveh,MyColor(0));
	if (!agmode || !frames.makeag(m))
		meta->replay(m);
	antialiasgraphics=al;
	setstyles();
	critical.leave();
	
	if (savewithantialias) // anti-aliasing on
	{	
		savew=savew/antialiasfactor; saveh=saveh/antialiasfactor;
		if (antialiasfactor==3 && !systemscaling) m->scale3(savew,saveh,sharper);
		else m->scale(savew,saveh);
	}
	
	BitmapPS *mcrop=cropbitmap(m);
	
	if (*Bitmapname.extension()==0) Bitmapname.cat(".png");
	if (!mcrop->savepng(Bitmapname))
		Warning("Could not open this file!","Save PNG",textwindow);
		
	delete mcrop;
		
	if (createbb)
	{	String *Name=new String(Bitmapname);
		Name->extension(".bb");
		FILE *out=fopen(Name->text(),"w");
		fprintf(out,"%%%%BoundingBox: 0 0 %d %d\n",mcrop->width(),mcrop->height());
		fclose(out);
	}
}

void docopywmf ()
{	
	EnhancedMetafilePS m(*graphicswindow->bitmap());

	Font mfont(GraphicsFontName,
		max(m.width(),m.height())/gscreenlines,Font::bold,gfontfixed);
	m.font(mfont);
	Font mufont(GraphicsFontName,
		max(m.width(),m.height())/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed,900);
	m.rememberfont(1,mufont);
	Font mdfont(GraphicsFontName,
		max(m.width(),m.height())/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed,2700);
	m.rememberfont(2,mdfont);

	critical.enter();
	meta->replay(&m,0);
	critical.leave();
	
	m.close();
	Clipboard c(*graphicswindow);
	EnhancedMetafile f(m);
	c.copy(f);
}

void docopy ()
{	
	Dialog d(textwindow,IDD_SaveBitmap);
	if (savew==0) // set default global variables
	{	
		savew=graphicswindow->displaywidth();
		saveh=graphicswindow->displayheight();
	}
	LongItem w(ID_Width,d,savew);
	LongItem h(ID_Height,d,saveh);
	WindowSize ws(ID_WindowSize,d,w,h);
	HelpButton help(d,"documentation/gui.html#Graphics_Export");
	Aspect aspect(ID_Aspect,d,w,h);
	if (saveb<0) saveb=usecolors?2:0;
	CheckItem aa(ID_AntiAlias,d,savewithantialias);

	// show dialog
	d.carryout();
	if (d.result()!=Dialog::ok) return;
	
	savew=w; saveh=h; saveb=24;
	if (savew<10) savew=10;
	if (saveh<10) saveh=10;
	savewithantialias=aa;

	if (savewithantialias)
	{
		savew=savew*antialiasfactor; saveh=saveh*antialiasfactor;
	}
	
	BitmapPS *m=new BitmapPS(*graphicswindow,savew,saveh);
	Font mfont(GraphicsFontName,
		max(savew,saveh)/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed);
	m->font(mfont);
	Font mufont(GraphicsFontName,
		max(savew,saveh)/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed,900);
	m->rememberfont(1,mufont);
	Font mdfont(GraphicsFontName,
		max(savew,saveh)/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed,2700);
	m->rememberfont(2,mdfont);

	critical.enter();
	int al=antialiasgraphics;
	antialiasgraphics=savewithantialias;
	set_styles(antialiasgraphics,linewidth(w,1,!fatterlines)/2);
	m->bar(0,0,savew,saveh,MyColor(0));
	if (!agmode || !frames.makeag(m))
		meta->replay(m);
	antialiasgraphics=al;
	setstyles();
	critical.leave();

	if (savewithantialias) // anti-aliasing on
	{	
		savew=savew/antialiasfactor; saveh=saveh/antialiasfactor;
		if (antialiasfactor==3 && !systemscaling) m->scale3(savew,saveh,sharper);
		else m->scale(savew,saveh);
	}
	
	BitmapPS *mcrop=cropbitmap(m);
	
	Clipboard c(*graphicswindow);
	c.copy((HBITMAP)mcrop->bitmaphandle());
}

String PostscriptName;

void dopostscript ()
{	
	if (!editing || nojump) return;
	PostscriptName.copy(savepostscript.select());
	if (PostscriptName.empty()) return;
	saveps (PostscriptName);
}

void saveps (char *filename)
{   
	PostscriptName.copy(filename);
	
	if (*PostscriptName.extension()==0) PostscriptName.cat(".eps");
	FILE *out=fopen(PostscriptName,"w");
    if (!out) return;
    meta->postscript(out);
    fclose(out);
}

String SVGName;

void dosvg ()
{	
	if (!editing || nojump) return;
	Dialog d(textwindow,IDD_SaveBitmap);
	if (savew==0) // set default global variables
	{	
		savew=graphicswindow->displaywidth();
		saveh=graphicswindow->displayheight();
	}
	LongItem w(ID_Width,d,savew);
	LongItem h(ID_Height,d,saveh);
	WindowSize ws(ID_WindowSize,d,w,h);
	HelpButton help(d,"documentation/gui.html#Graphics_Export");
	Aspect aspect(ID_Aspect,d,w,h);
	if (saveb<0) saveb=usecolors?2:0;

	d.carryout();
	if (d.result()!=Dialog::ok) return;
	
	savew=w; saveh=h;
	
	SVGName.copy(savesvgfile.select());
	if (SVGName.empty()) return;
	savesvg(SVGName,savew,saveh);
}

void insert_latex (char *formula)
{
	char *filename=
		text->makelatexpng(formula,latexmagnify,text->textheight(),latextransparent,0);
	if (filename)
	{
		load_image(25,filename,1.0,latexantialias?(latexkeeplarge?2:1):0,formula,0);
	}
}

void dopasteimage ()
{
	if (!editing || nojump) return;

	Clipboard c(*graphicswindow);
	Gdiplus::Bitmap *im=c.getbitmap();
	if (im)
	{
		if (*NotebookName==0)
		{	
			Warning("Notebook needs to be saved first!","Euler");
			if (!dosaveas()) return;
		}

		String filename(NotebookName);
		if (imagesindirectory)
		{	
			filename.copy("images\\");
			if (!exists(filename.text())) _mkdir(filename.text());
			filename.cat(NotebookName);
		}

		filename.cat("-clipboard-");
		int n=1;
		while (true)
		{
			char s[16];
			String fn(filename);
			sprintf(s,"%03d",n);
			fn.cat(s); fn.cat(".png");
			if (!exists(fn.text()))
			{
				BitmapPS *m=new BitmapPS(textwindow,im);
				m->save(fn.text());
				if (text->cursorline()->length()>1)
				{	text->insertline();
					text->cursorline()->type(TextLine::prompt);
				}
				text->cursorline()->copy(">loadimg(25,\"");
				text->cursorline()->cat(fn.text());
				text->cursorline()->cat("\");");
				text->execute();
				text->unmarkall();
				return;
			}
			n++;
		}

	}
	else
	{
		Warning("No image on clipboard!","Euler");
	}
}

// ***** Save Graphics as metafile *****

MetafilePS *usedmetasave;

int metasaveit ()
{	
	MetafilePS &m=*usedmetasave;
	Font mfont(GraphicsFontName,max(savew,saveh)/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed);
	m.font(mfont);
	Font mufont(GraphicsFontName,max(savew,saveh)/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed,900);
	m.rememberfont(1,mufont);
	Font mdfont(GraphicsFontName,max(savew,saveh)/gscreenlines,boldfont?Font::bold:Font::normal,gfontfixed,2700);
	m.rememberfont(2,mdfont);

	critical.enter();
	meta->replay(&m);
	critical.leave();
	
	m.close();
	PlaceableMetafile f(m);
	f.save(Bitmapname);
	delete usedmetasave;
	return 0;
}

// **** Dialog to choose both fonts ****

class TextFontButton : public ButtonItem
{   int N;
	LongItem *L;
	Font *F;
	StringItem *S;
	public :
	TextFontButton (int id, Dialog &d, LongItem &l, Font &f,
			StringItem &s) :
		ButtonItem(id,d),N(0),L(&l),F(&f),S(&s)
	{}
	virtual int command (LPARAM p)
	{	FontDialog fd(*F);
		if (fd.select(textwindow,FontDialog::screen|FontDialog::fixed))
		{	N++;
			WindowPS ps(textwindow);
			ps.font(*F);
			L->set(ps.textheight());
			S->set(F->name());
		}
		return 1;
	}
	int n () { return N; }
};

class GraphicsFontButton : public ButtonItem
{   int N;
	LongItem *L;
	Font *F;
	StringItem *S;
	public :
	GraphicsFontButton (int id, Dialog &d, LongItem &l, Font &f,
			StringItem &s) :
		ButtonItem(id,d),N(0),L(&l),F(&f),S(&s)
	{}
	virtual int command (LPARAM p)
	{	FontDialog fd(*F);
		if (fd.select(textwindow,
			FontDialog::init|FontDialog::scalable|FontDialog::screen|FontDialog::fixed))
		{	N++;
			WindowPS ps(*graphicswindow);
			ps.font(*F);
			L->set(max(graphicswindow->bitmapheight(),graphicswindow->bitmapwidth())
				/ps.textheight());
			S->set(F->name());
		}
		return 1;
	}
	int n () { return N; }
};

class DefaultFontsButton : public ButtonItem
{   public :
	DefaultFontsButton (int id, Dialog &d)
		: ButtonItem(id,d)
	{}
	virtual int command (LPARAM p)
	{	
		GraphicsFontName.copy("Arial");
		TextFontName.copy("Courier New");
		gscreenlines=40;
		graphicswindow->sized();
		tfontheight=16;
		textwindow.sized();
		return 0;
	}
};

// Menu function for setting the fonts.
void dosetfonts ()
{   
	Font tfont(GraphicsFontName,tfontheight,boldfont?Font::bold:Font::normal);
	Font gfont(TextFontName,max(graphicswindow->adjwidth(),
		graphicswindow->adjheight())/gscreenlines);
	Dialog d(textwindow,IDD_Fonts);
	LongItem gn(ID_GraphicsFont,d,gscreenlines);
	LongItem tn(ID_TextFont,d,tfontheight);
	StringItem gs(ID_GraphicsFontName,d,GraphicsFontName);
	StringItem ts(ID_TextFontName,d,TextFontName);
	StringItem pname(ID_PrinterName,d,Printer);
	GraphicsFontButton gf(ID_SelectGraphicsFont,d,gn,gfont,gs);
	TextFontButton tf(ID_SelectTextFont,d,tn,tfont,ts);
	DefaultFontsButton button(ID_DefaultFonts,d);
	HelpButton help(d,"reference/overview.html#Graphics%C2%A0Options");

	d.carryout();
	if (d.result()!=Dialog::ok) return;

	int n;
	n=gn;
	GraphicsFontName.copy(gs);
	if (n>10 && n<200) gscreenlines=n;
	graphicswindow->timedsized(1);
	n=tn;
	TextFontName.copy(ts);
	tfontheight=n;
	textwindow.sized();

}

// Set the graphics font in lines per screen.
// This function can be used in Euler programs via the setfont function.
int setfont (int n, char *name)
{
	int nold;
	if (n==0)
	{
		gscreenlines=profile.readint("graphicslines",40);
		GraphicsFontName.copy(profile.read("graphicsfontname","Arial"));
		nold=40;
	}
	else
	{
		if (n<10) n=10;
		if (n>200) n=200;
		nold=gscreenlines;
		gscreenlines=n;
		if (*name) GraphicsFontName.copy(name);
	}
	graphicswindow->timedsized(1);
	return nold;
}

void doenlarge ()
{
	enlarge=!enlarge;
	menu.check(IDM_Size150,enlarge);
	textwindow.sized();
}

class SetAspectButton : ButtonItem
{
	DoubleItem Aspect;
	double V;
	public :
	SetAspectButton (int id, Dialog &d,
		DoubleItem &aspect, double v)
		: ButtonItem(id,d),Aspect(aspect),V(v)
	{}
	int command (LPARAM p)
	{	
		Aspect.set(V);
		return 1;
	}
};

void dosetaspect ()
{
	if (!editing || nojump || text->type()!=TextLine::prompt) return;

	Dialog d(textwindow,IDD_SetAspect);

	CheckItem gw(ID_GraphicsWindow,d,!savecropsquare);
	DoubleItem ga(ID_GraphicsAspect,d,saveaspect);

	SetAspectButton b1(ID_1_1,d,ga,1.0);
	SetAspectButton b2(ID_3_2,d,ga,1.5);
	SetAspectButton b3(ID_2_1,d,ga,2.0);
	SetAspectButton b4(ID_16_9,d,ga,16.0/9.0);

	HelpButton help(d,"reference/overview.html#Plot%C2%A0Aspect");

	d.carryout();

	if (d.result()==Dialog::ok)
	{
		savecropsquare=cropsquare=!gw;
		saveaspect=aspect=ga;
		if (aspect<0.1) aspect=0.1;
		if (aspect>10) aspect=10;
		intextwindow=0;
		graphicswindow->sized();
	}
}

double getaspect ()
{
	if (cropsquare) return aspect;
	else return graphicswindow->aspect();
}

double setaspect (double x)
{
	double old=aspect;
	if (x==0)
	{
		cropsquare=savecropsquare;
		aspect=saveaspect;
	}
	else
	{
		cropsquare=1;
		aspect=x;
		if (aspect<0.1) aspect=0.1;
		if (aspect>10) aspect=10;
	}
	if (!intextwindow) graphicswindow->show();
	graphicswindow->timedsized();
	return old;
}

void dointextwindow ()
{
	if (showgraphics) return;
	intextwindow=!intextwindow;
	menu.check(IDM_InTextWindow,intextwindow);
	if (intextwindow) graphicswindow->hide();
	else graphicswindow->show();
	graphicswindow->timedsized(1);
	textwindow.top();
}

void dofatterlines ()
{
	fatterlines=!fatterlines;
	menu.check(IDM_FatterLines,fatterlines);
	graphicswindow->sized();
}

void doboldfont ()
{
	boldfont=!boldfont;
	menu.check(IDM_BoldFont,boldfont);
	graphicswindow->sized();
}

void doresetdefaults ()
{
	Message("To reset Euler Math Toolbox\n"
		"delete the file \".euler.cfg\"\n"
		"in your home directory!",
		"Reset Euler");
}

// **** Dialog to set the 16 default colors ****

class ColorItem : public UserItem
{   int I;
	Color C;
	public :
	ColorItem (int id, Dialog &d, int i, Color c) :
		UserItem(id,d),I(i),C(c) {}
	virtual void redraw (PS &ps)
	{	ps.bar(0,0,ps.width(),ps.height(),C);
	}
	void set (Color c) { C=c; update(); }
};

Color *textcolors[6] = {textblack,textred,textgreen,
	textblue,textwhite,textmarked};
Color *deftextcolors[6] = {&deftextblack,&deftextred,&deftextgreen,
	&deftextblue,&deftextwhite,&deftextmarked};

class SetColorItem : public ButtonItem
{	int I;
	Color C;
	ColorItem *Ci;
	public :
	SetColorItem (int id, Dialog &d, int i, ColorItem &ci, Color c) :
		ButtonItem(id,d),I(i),C(c),Ci(&ci) {}
	virtual int command (LPARAM p)
	{   ColorSelector s(textwindow,C);
		Color H=s.select();
		if (s.result()==Dialog::ok)
		{	C=H;
			Ci->set(H);
		}
		return 1;
	}
	void set (Color c) { C=c; }
	Color color () { return C; }
};

class ColorDefaultButton : public ButtonItem
{   ColorItem **C,**Ct;
	SetColorItem **Cs,**Cst;
	public :
	ColorDefaultButton (int id, Dialog &d, 
		ColorItem **c, SetColorItem **cs,
		ColorItem **ct, SetColorItem **cst)
		: ButtonItem(id,d),C(c),Cs(cs),Ct(ct),Cst(cst)
	{}
	virtual int command (LPARAM p);
};

int ColorDefaultButton::command (LPARAM p)
{	
	for (int i=0; i<16; i++)
	{	C[i]->set(Color(red[i],green[i],blue[i]));
		Cs[i]->set(Color(red[i],green[i],blue[i]));
	}
	for (int i=0; i<6; i++)
	{	Ct[i]->set(*deftextcolors[i]);
		Cst[i]->set(*deftextcolors[i]);
	}
	return 1;
}

void dosetcolors ()
{	
	Dialog d(textwindow,IDD_Colors);
	int i;
	ColorItem *CI[16];
	for (i=0; i<16; i++) CI[i]=new ColorItem(100+i,d,i,mycolors.fillcolor(i));
	SetColorItem *SCI[16];
	for (i=0; i<16; i++) SCI[i]=new SetColorItem(200+i,d,i,*CI[i],mycolors.fillcolor(i));
	ColorItem *CIT[6];
	for (i=0; i<6; i++) CIT[i]=new ColorItem(400+i,d,i,*textcolors[i]);
	SetColorItem *SCIT[6];
	for (i=0; i<6; i++) SCIT[i]=new SetColorItem(300+i,d,i,*CIT[i],*textcolors[i]);
	ColorDefaultButton b(ID_DefaultColors,d,CI,SCI,CIT,SCIT);
	HelpButton help(d,"documentation/gui.html#Colors");
	
	d.carryout();

	if (d.result()==Dialog::ok)
	{	
		for (i=0; i<16; i++) savecolors.set(i,SCI[i]->color());
		for (i=0; i<16; i++) mycolors.set(i,SCI[i]->color());
		for (i=0; i<6; i++) *textcolors[i]=SCIT[i]->color();
	}
	for (i=0; i<16; i++) delete CI[i];
	for (i=0; i<16; i++) delete SCI[i];
	for (i=0; i<6; i++) delete CIT[i];
	for (i=0; i<6; i++) delete SCIT[i];
	textwindow.update();
}

void dosplitcommand ()
{	
	if (!editing || nojump || udf==1) return;
	text->splitcommand();
}

void dosplitline ()
{	
	if (!editing || nojump || udf==1) return;
	text->splitcommand(0);
}

void dojoinlines ()
{	
	if (!editing || nojump || udf==1) return;
	text->joinline();
}

void doclearcommandline ()
{
	if (!editing || nojump || udf==1) return;
	text->set("",lefteditlimit);
}

//********* Recent files **************

#define maxrecent 20
String *Recent[maxrecent];

void dorecent ()
// see, if the user has chosen a recent file.
// this functions is asigned to all menu entries in the recent
// file list.
{	
	if (!editing || nojump) return;
	int i=menu.command()-5000;
	if (Recent[i]) 
	{	if (!exists(Recent[i]->text()))
		{	Warning("File does no longer exist!","Load Recent");
			return;
		}
		if (text->changed() && text->countlines()>1 &&
			(!askconfirmations || Question("Save this Notebook\nbefore deleting it?",
				"Euler",textwindow)==Answers::yes))
		{	dosave();
		}
		String Name(Recent[i]->text());
		if (alwaysrestart)
		{	dorestart(0);
			wantload.copy(Name.text());
		}
		else
		{	doopenfinish(Name.text());
		}
	}
}

void getrecent ()
// load the recent file list from the registry
{	
	critical.enter();
	int i;
	char s[20];
	String r;
	for (i=0; i<maxrecent; i++) Recent[i]=0;
	int ci=0;
	for (i=0; i<maxrecent; i++)
	{	
		sprintf(s,"recent%d",i);
		r.copy(profile.read(s,""));
		if (r.length()>0 && exists(r.text()))
		{	int have=0;
			for (int j=0; j<ci; j++)
			{	have=!strcmp(Recent[j]->text(),r.text());
				if (have) break;
			}
			if (!have) Recent[ci++]=new String(r);
		}
	}
	critical.leave();
}

void makerecent ()
// make the menu for the recent files
{	
	critical.enter();
	int i;
	for (i=0; i<maxrecent; i++)
	{	
		if (Recent[i])
		{	
			String *s=new String(Recent[i]->text());
			*(s->extension())=0;
			menu.append(1,5000+i,s->filename(),dorecent);
		}
	}
	critical.leave();
}

void clearrecent ()
// clear the recent file list
{	
	critical.enter();
	int i;
	for (i=0; i<maxrecent; i++)
	{	if (Recent[i])
			menu.remove(1,5000+i);
	}
	critical.leave();
}

void doclearrecent ()
{	
	clearrecent();
	char s[20];
	for (int i=0; i<maxrecent; i++)
	{	sprintf(s,"recent%d",i);
		profile.remove(s);
		Recent[i]=0;
	}
}

void saverecent ()
// save the recent file list to the registry
{	
	critical.enter();
	int i;
	char s[20];
	String r;
	for (i=0; i<maxrecent; i++)
	{	if (Recent[i])
		{	sprintf(s,"recent%d",i);
			profile.write(s,Recent[i]->text());
		}
	}
	critical.leave();
}

void addrecent (char *s)
// add a file to the recent file list
{	
	if (automatic) return;
	critical.enter();
	clearrecent();
	int i,j;
	for (i=0; i<maxrecent; i++)
	{	while (Recent[i] && 
			strcmp(Recent[i]->text(),s)==0)
		{	for (j=i; j<maxrecent-1; j++)
				Recent[j]=Recent[j+1];
			Recent[maxrecent-1]=0;
		}
	}
	for (i=0; i<maxrecent; i++)
	{	if (!Recent[i])
		{	Recent[i]=new String(s);
			makerecent();
			critical.leave();
			return;
		}
	}
	for (int i=0; i<maxrecent-1; i++)
	{	if (!Recent[i])
		{	Recent[i]=new String(s);
			makerecent();
			critical.leave();
			return;
		}
		Recent[i]=Recent[i+1];
	}
	Recent[maxrecent-1]=new String(s);
	makerecent();
	critical.leave();
}

// ************ Help function ****************

char *getline (FILE *in, char *line, int maxline=1024)
{	char *p=fgets(line,maxline-2,in);
	while (p)
	{	int n=(int)strlen(p);
		if (n>0 && (p[n-1]==10 || p[n-1]==13)) p[n-1]=0;
		else break;
	}
	return p;
}

// ************* Help Sections ***************

#define nhelpsections 31
char * helpsections[nhelpsections] = {
	"Help","Keyboard","Variables","Data Types","Comments",
	"Plots in 2D","Plots in 3D","Logarithmic Plots","Solve Equations","Differential Equations",
	"Optimization","Algebra","Integrals","Regression","Formats",
	"Units","Interval Arithmetic","Polynomials and Splines","Programming Language","Symbolic Functions",
	"Scripts","Variables in Functions","Symbolic Variables","parameters","map",
	"Plot Styles","Basic Plots","Matrices","Matrix Language","Statistics",
	"Statistical Plots",
};

void dohelpsections ()
// call the help section with menu id 9000,9001, etc. based
// on the names of the array char * helpsections[].
{
	int k=menu.command()-9000;
	if (k<0 || k>=nhelpsections) return;
	char s[256];
	strcpy(s,helpsections[k]);
	char *p=s;
	while (*p)
	{
		if (*p==' ') *p=(unsigned char)160;
		p++;
	}
	doeulerhelp(s);
}

void make_helpsections ()
{
	for (int i=0; i<nhelpsections; i++) menu.add(9000+i,dohelpsections);
}

// ************ User Commands Menu ****************

#define USERMENU 11000

int nusermenu=0;
#define MAXEXAMPLES 1024
String *usermenu[MAXEXAMPLES];
#define MAXSUBMENUS 16
String *submenu[MAXSUBMENUS];
HMENU hsubmenu[MAXSUBMENUS];
int nsubmenus=0;
String currentsubmenu("Other");

void dousermenu();

char *clean_menuentry (char *s)
{	
	static char t[256];
	char *p=t;
	while (*s)
	{	if (*s!='?' && *s!='%') *p++=*s;
		s++;
	}
	*p=0;
	return t;
}

void add_usermenu (char *item, char *submenuname)
{	
	if (nusermenu==0) menu.remove(MENU_USER,USERMENU);
	int cn=-1;
	for (int i=0; i<nsubmenus; i++)
	{	
		if (strcmp(submenuname,submenu[i]->text())==0)
		{	cn=i; break;
		}
	}
	if (cn==-1)
	{	
		HMENU current=CreatePopupMenu();
		AppendMenu((HMENU)menu.submenu(MENU_USER),MF_POPUP,(UINT_PTR)current,
			submenuname);
		submenu[nsubmenus]=new String(submenuname);
		hsubmenu[nsubmenus]=current;
		cn=nsubmenus;
		nsubmenus++;
	}
	// already present?
	for (int i=0; i<nusermenu; i++)
	{	
		if (strcmp(item,usermenu[i]->text())==0)
			return;
	}
	// add it!
	menu.add(USERMENU+nusermenu,dousermenu);
	AppendMenu(hsubmenu[cn],MF_STRING,USERMENU+nusermenu,clean_menuentry(item));
	usermenu[nusermenu++]=new String(item);
}

void addmenu (char *item)
{	
	add_usermenu(item,currentsubmenu.text());
}

void addsubmenu (char *item)
{	
	currentsubmenu.copy(item);
}

void addloadedfile (char *item)
{
	String s(item);
	if (s.endsWith(".cfg")) return;
	if (!s.endsWith(".e")) s.cat(".e");
	add_usermenu(s.filename(),"Loaded Euler Files");
}

void dousermenu ()
// Called by the menu callback for the User menu.
// Paste a Maxima command into the command line,
// if the command line is a Maxima command in compatibility mode.
{	
	if (!editing || nojump) return;
	int i=menu.command()-USERMENU;
	if (i>=0 && i<nusermenu) 
	{	
		String s(usermenu[i]->text());
		if (s.endsWith(".e"))
		{
			doeulerhelp(s.text());
			return;
		}
		else if (s.startsWith("::"))
		{	s.del(0,2);
			if (s.startsWith(" ")) s.del(0,1);
			if (text->cursorline()->length()==1) text->inserttext(":: ");
			if (!text->cursorline()->startsWith(">::")) return;
		}
		else if (s.startsWith("&"))
		{	s.del(0,1);
			if (s.startsWith(" ")) s.del(0,1);
			if (text->cursorline()->length()==1) text->inserttext(":: ");
			if (!text->cursorline()->startsWith(">::")) return;
		}
		int n=s.find("%");
		if (n>=0)
			// position the cursor at the %
		{	s.text()[n]=0;
			text->inserttext(s);
			int np=text->cursorpos();
			s.text()[n]='%';
			text->inserttext(s.text()+n+1);
			text->setcursorpos(np);
		}
		else if ((n=s.find("?"))>=0)
		{	s.text()[n]=0;
			text->inserttext(s);
			int np=text->cursorpos();
			s.text()[n]='?';
			text->inserttext(s.text()+n);
			text->setcursorpos(np);
		}
		else
			// just append the command
		{	text->inserttext(s);
		}
		text->unmarkall();
		textwindow.update();
	}
}

void clear_usermenu ()
{	
	if (nusermenu==0) return;
	for (int i=0; i<nusermenu; i++)
	{	
		menu.remove(MENU_USER,USERMENU+i);
		delete usermenu[i];
	}
	for (int i=nsubmenus+1; i>=0; i--)
	{	
		DeleteMenu((HMENU)menu.submenu(MENU_USER),0,MF_BYPOSITION);
		delete submenu[i];
	}
	menu.append(MENU_USER,USERMENU,"Currently empty!",dousermenu);
	nusermenu=0;
	nsubmenus=0;
	currentsubmenu.copy("Other");
}

// ********* Pixel Service for Images ********

int get_pixels (char *filename, double *m, int *r, int *c)
// load a pixel bitmap from a file.
// the file is PNG, and the bitmap matrix contains one
// double for each pixel in compressed RGB format.
{	
	String name(filename);
	if (*name.extension()==0) name.cat(".png");
	if (!exists(name.text())) return 0;
	BitmapPS *bitmap=new BitmapPS(textwindow,name.text());
	if (bitmap->bitmaphandle()==0) return 0;
	BYTE *x=bitmap->getBits();
	*r=bitmap->height(),*c=bitmap->width();
	int d=(*c)%4;
	for (int i=0; i<*r; i++)
	{	for (int j=0; j<*c; j++)
		{	*m++=((256+*(x+2))*256+*(x+1))*256+*x;
			if ((char *)m > ramend-10) { error=1; return 0; }
			x+=3;
		}
		x+=d;
	}
	return 1;
}

int put_pixels (char *filename, double *m, int r, int c)
// save a pixel bitmap matrix to that file in PNG format.
// the matrix contains one double for each pixel
// in compressed RGB format.
{	
	String name(filename);
	if (*name.extension()==0) name.cat(".png");
	// create a bitmap from the data
	BitmapPS *bitmap=new BitmapPS(textwindow,c,r);
	BYTE *b=bitmap->getBits();
	BYTE *x=b;
	int d=c%4;
	for (int i=0; i<r; i++)
	{	for (int j=0; j<c; j++)
		{	unsigned long k=(unsigned long)(*m++);
			*x++=(byte)(k&0x000000FF);
			*x++=(byte)((k&0x0000FF00)>>8);
			*x++=(byte)((k&0x00FF0000)>>16);
		}
		x+=d;
	}
	bitmap->setBits(b);
	delete(b);
	// save it
	return bitmap->savepng(filename);
}

// ************* cropmode ***********************

int cropmode=0;
double cropleft=0,cropright=0,croptop=0,cropbottom=0;

void docrop ()
// go into crop mode
{	
	if (!editing) return;
	cropleft=cropright=cropbottom=croptop=0;
	cropmode=1;
	if (intextwindow) showgraphics=1;
	graphicswindow->update();
	graphic_mode();
	doreplay();
	textwindow.setstatus("Drag a crop area with the mouse! End with Return!");
}

void stopcrop ()
{	
	cropleft=cropright=cropbottom=croptop=0;
	cropmode=0;
	doreplay();
	text_mode();
	textwindow.setstatus("");
}

void endcrop ()
{	
	cropmode=0;
	doreplay();
	text_mode();
	textwindow.setstatus("");
}

// *********** Toggle Anti-Alias *****************

void doantialias ()
{
	antialiasgraphics=!antialiasgraphics;
	menu.check(IDM_antialiasgraphics,antialiasgraphics);
	graphicswindow->sized();
}

// ********* Not a number NAN *******************

// unsigned long nan[2]={0xffffffff, 0x7fffffff};
// double NAN=*(double*)nan; // system dependend NAN
int pnan=0; // flag: produce NAN (or produce errors)
int usenan=0; // flag: pnan set to 1 for one command
int underflows=0; // produce underflow errors

int _matherr (struct _exception *except)
{   if (!pnan) error=ERROR_FLOATING_POINT;
	return 0;
}

int isnan (double x)
// system dependend function to detect a NAN in IEEE
{	return !(x==x);
}

char *format_udfline (char *s);

void notify_error (char *next)
{	
	if (udfon) next=format_udfline(next);
	if (automatic) dump("Error in automatic mode!\n%s",next);
}

void show_script_error ()
{
	// textwindow.show();
}


/************************************************************/

int startup ()
{	
	textwindow.startupdatetimer();
	if (startmaxima && !script) start_maxima(getstartdir());
#ifdef YACAS
	if (startyacas) init_yacas();
#endif
	croptop=0; cropbottom=0; cropleft=0; cropright=0;
	textwindow.sized();
	error=0;
	return 1;
}

class StartupThread : public Thread
{	
	public :
	StartupThread () : Thread(startup) {}
} startupthread;

void dostartup ()
{	
	startupthread.start();
}

// ****************** New Version Thread *********************

#include <WinInet.h>

int checkcall=0;

int newversion ()
{
	int found=0;
	if (!checkcall) Sleep(1000);
	HINTERNET hinternet;
	hinternet=InternetOpen("Euler",INTERNET_OPEN_TYPE_DIRECT,0,0,0);
	if (!hinternet)
	{
		if (checkcall) Message("Internet is not available!","Euler"); 
		return 1;
	}
	HINTERNET hin=InternetOpenUrl(hinternet,"http://www.euler-math-toolbox.de/Programs/Changes.html",
		0,0,INTERNET_FLAG_RELOAD,0);
	if (!hin)
	{
		if (checkcall) Message("Web page could not be found!","Euler"); 
		return 1;
	}
	static char buffer[1024];
	static DWORD bytesread;
	InternetReadFile(hin,buffer,1020,&bytesread);
	if (bytesread>0)
	{
		char *p=buffer;
		while (*p)
		{
			if (strncmp(p,"Version ",8)==0)
			{
				p+=8;
				char *rv=profile.read("showedversion",version.text());

				// dump("---%s---\n---%s---",version.text(),p);

				if (strncmp(p,version.text(),10)!=0 && 
					(checkcall || strncmp(p,rv,strlen(rv))!=0))
				{	
					found=1;
					static char sv[1024];
					char *h=sv;
					while (xisdigit(*p) || xisalpha(*p) || *p=='.') { *h++=*p++; }
					*h++=0;
					if (!checkcall) profile.write("showedversion",sv);
					STARTUPINFO si; // structure to start a process
					PROCESS_INFORMATION pi; // structure to get back process information
		
					sprintf(sv,"cmd /c start http://www.euler-math-toolbox.de/Programs/Changes.html");
					ZeroMemory( &si, sizeof(si) );
					si.cb = sizeof(si);
		
					ZeroMemory( &pi, sizeof(pi) );
		
					if (!CreateProcess(0,sv,0,0,0,CREATE_NO_WINDOW,0,0,&si,&pi))
					{
						char ws[MAXLINE+255];
						sprintf(ws,"Could not open the browser!\nTry editing the browser settings.\nCommand Line was:\n%s",sv);
						if (checkcall) Warning(ws,"Euler");
						return 1;
					}
					CloseHandle( pi.hProcess );
					CloseHandle( pi.hThread );
				}
				break;
			}
			p++;
		}
	}
	else 
	{
		if (checkcall) Message("Web page could not be found!","Euler");
		return 1;
	}
	InternetCloseHandle(hin);
	InternetCloseHandle(hinternet);
	if (!found && checkcall) Message("Your program version is up to date.","Euler");
	return 1;
}

class NewVersionThread : public Thread
{
public :
	NewVersionThread () : Thread(newversion) {}
} newversionthread;

void docheck ()
{
	checkcall=1;
	newversionthread.start();
}

int fullscreen=0;
int oldtx,oldty,oldtw,oldth;
int oldgx,oldgy,oldgw,oldgh;
LONG twstyle;
int olditw;

int screenchanged=0;

void dofullscreen ()
{
	if (fullscreen==1) 
	{
		SetWindowLong(textwindow.handle(), GWL_STYLE, twstyle);
		SetMenu(textwindow.handle(),(HMENU)menu.handle());
		if (olditw!=intextwindow) dointextwindow();
		textwindow.setsize(oldtx,oldty,oldtw,oldth);
		fullscreen=0;
	}
	else if (fullscreen==2)
	{
		if (olditw!=intextwindow) dointextwindow();
		textwindow.setsize(oldtx,oldty,oldtw,oldth);
		graphicswindow->setsize(oldgx,oldgy,oldgw,oldgh);
		fullscreen=0;
	}
	else
	{
		textwindow.getsize(oldtx,oldty,oldtw,oldth);
		graphicswindow->getsize(oldgx,oldgy,oldgw,oldgh);
		RECT r;
		SystemParametersInfo(SPI_GETWORKAREA,0,&r,0);
		if (r.bottom-r.top<800)
		{
			SetMenu(textwindow.handle(),0);
			LONG lStyle = GetWindowLong(textwindow.handle(), GWL_STYLE);
			twstyle=lStyle;
			lStyle &= ~(WS_CAPTION | WS_THICKFRAME | WS_MINIMIZE | WS_MAXIMIZE | WS_SYSMENU);
			SetWindowLong(textwindow.handle(), GWL_STYLE, lStyle);
			textwindow.setsize(r.left,r.top,r.right-r.left,r.bottom-r.top);
			fullscreen=1;
			olditw=intextwindow;
			if (!intextwindow) dointextwindow();
		}
		else
		{
			int tw=oldtw;
			int sw=r.right-r.left;
			if (2*tw<sw) tw=(sw)/2;
			textwindow.setsize(r.left,r.top,tw,r.bottom-r.top);
			olditw=intextwindow;
			if (intextwindow) dointextwindow();
			int sh=r.bottom-r.top;
			int gw=r.right-r.left-tw-10;
			if (gw>sh) gw=sh;
			graphicswindow->setsize(r.left+tw+10,r.top+(sh-gw)/2,gw,gw);
			fullscreen=2;
		}
	}
	screenchanged = 1; // tells the event handler to call sized()
}

void doopensecond ()
{
	char sv[MAXLINE];

	STARTUPINFO si; // structure to start a process
	PROCESS_INFORMATION pi; // structure to get back process information
		
#ifdef WIN64
	sprintf(sv,"%s\\euler64.exe -second",getstartdir());
#else
	sprintf(sv,"%s\\euler.exe -second",getstartdir());
#endif
	ZeroMemory( &si, sizeof(si) );
	si.cb = sizeof(si);
		
	ZeroMemory( &pi, sizeof(pi) );
		
	if (!CreateProcess(0,sv,0,0,0,CREATE_NO_WINDOW,0,0,&si,&pi))
	{
		char ws[MAXLINE+255];
		sprintf(ws,"Could not open EMT!\nCommand Line was:\n%s",sv);
		Warning(ws,"Euler");
		return;
	}
	CloseHandle( pi.hProcess );
	CloseHandle( pi.hThread );
}

//*********** Style Files *************************

void patterncopy (char *filename)
{
	char s[MAXLINE];
	sprintf(s,"%s\\docs\\%s.html",getstartdir(),filename);
	file_copy(s,"Pattern.html");
}

void doeulerdefault ()
{
	patterncopy("EulerDefault");
}

void doeulerblackandwhite ()
{
	patterncopy("EulerBlackAndWhite");
}

void doeulerwebfont ()
{
	patterncopy("EulerWebFont");
}

//*************** Spell Check *********************

void dospellcheck ()
{
	spellcheck=!spellcheck;
	menu.check(IDM_spellcheck,spellcheck);
	if (spellcheck) text->spellcheck();
	else text->unmarkspellerrors();
}

void doaddwords ()
{
	char line[MAXLINE];
	sprintf(line,"%suser.words",getusereulerdir());
	text->addwords(line);
}

void doenglish ()
{

}

void dogerman ()
{

}

//****************** Main Program *****************

void closelibs (); // Close all opened DLLs

#include <locale.h>

#define CHECK(item)\
	item=profile.readint(#item,item);\
	menu.check(IDM_##item,item);\
	menu.add(IDM_##item,&item);

#define LOAD(item)\
	item=profile.readint(#item,item);

#define SAVE(item)\
	profile.writeint(#item,item);

int winmainhandled (int argc, char *argv[])
/******
Initialize memory and call main_loop
******/
{	
	int i,x,y,w,h;
	int reset=0;

#ifdef DUMP
	initdump("c:\\euler\\dump.txt");
#endif

	while (true)
	{
		if (argc>=2 && strcmp(argv[1],"-reset")==0)
		{  
			reset=1;
			argv++; argc--;
		}	
		else if (argc>=3 && strcmp(argv[1],"-script")==0 && argv[2][0]!='-')
		{  
			script=1;
			argv++; argc--;
		}	
		else if (argc>=2 && strcmp(argv[1],"-second")==0)
		{  
			second=1;
			argv++; argc--;
		}	
		else break;
	}

	setlocale(LC_CTYPE,"");

	homedir.copy(_getcwd(NULL,1024));
	homedir.cat("\\");

	// determine start directory
	String dir(program.filename());
	dir.stripfilename();
	startdir.copy(dir);

	// read the program version from version.txt
	getversion();

	// read character translations from file
	String tdir(dir);
	tdir.cat("translations.txt");
	if (exists(tdir)) translations_init(tdir.text());

	if (argc>=3 && strcmp(argv[1],"-home")==0)
	{   
		String name;
		name.copy(argv[2]);
		name.stripapostroph();
		name.cat("\\");
		dir.copy(name);
		name.cat("Euler Files\\");
		if (!exists(name.text())) _mkdir(name.text());
		argv++; argc--;
		argv++; argc--;
	}	

	extern int CODE_PAGE;
	
	if (argc >= 3 && strcmp(argv[1], "-codepage") == 0)
	{
		String name;
		name.copy(argv[2]);
		int k = atoi(name);
		if (k > 0) CODE_PAGE = k;
		argv++; argc--;
		argv++; argc--;
	}

	if (argc>=2 && strcmp(argv[1],"-run")==0)
	{   
		automatic=1;
		argv++; argc--;
	}	

	if (argc>=2 && strcmp(argv[1],"-xrun")==0)
	{   
		automatic=2;
		updatecomments=1;
		argv++; argc--;
	}	

	// look for USB stick configuration
	eulerfiles.copy(dir);
	eulerfiles.cat("Euler Files\\");
	if (exists(eulerfiles.text()))
	{	
		saveprofile=1;
	}
	else 
	{
		dir.copy(getuserhome());
		saveprofile=1;
	}

	// look for profile
	profiledir.copy(dir);
	profiledir.cat(".euler.profile");
	int newuser=0;
	if (!exists(profiledir.text())) newuser=1;
	if (saveprofile && !newuser) profile.readInputFile(profiledir.text());

	int firststart = (profile.readint("started",0)==0);

#ifdef WIN64
	stacksize=profile.readint("stacksize64",stacksize);
	if (stacksize<256) stacksize=256;
	graphicssize=profile.readint("graphicssize64",graphicssize);
	if (graphicssize<128) graphicssize=128;
#else
	stacksize=profile.readint("stacksize",stacksize);
	if (stacksize<128) stacksize=128;
	graphicssize=profile.readint("graphicssize",graphicssize);
	if (graphicssize<32) graphicssize=32;
#endif
	if (!memory_init())
	{	dump("Out of memory space!");
		return 1;
	}

	int gs=graphicssize;
	meta=new WindowsMeta(graphicssize);
	if (graphicssize!=gs) 
		DumpWarning("Could not allocate %d MB for graphics\nUsing %d MB.","Euler",
			gs,graphicssize);

	RECT r;
	
	if (SystemParametersInfo(SPI_GETWORKAREA,0,&r,0)==0)
	{
		Desktop dt;
		int dw, dh;
		dt.getsize(dw,dh);
		r.left=0; r.right=dw;
		r.top=0; r.bottom=dh;
		if (dh<=640) smallscreen=1;
		wscreen=dw; hscreen=dh;
	}
	else
	{
		wscreen=r.right-r.left;
		hscreen=r.bottom-r.top;
	}

	sprintf(Resolution.text(),"%d-%d-",r.right,r.bottom);

	gscreenlines=profile.readint("graphicslines",gscreenlines);
	tfontheight=profile.readint("textfont",tfontheight);
	TextFontName.copy(profile.read("textfontname",TextFontName));
	GraphicsFontName.copy(profile.read("graphicsfontname",GraphicsFontName));
	Printer.copy(profile.read("printer",""));
	menu.check(IDM_Size150,enlarge);
	cropsquare=savecropsquare=profile.readint("cropsquare",savecropsquare);
	aspect=saveaspect=profile.readdouble("aspect",aspect);
	boldfont=profile.readint("boldfont",boldfont);
	menu.check(IDM_BoldFont,boldfont);
	fatterlines=profile.readint("fatterlines",fatterlines);
	menu.check(IDM_FatterLines,fatterlines);
	intextwindow=profile.readint(addres("intextwindow"),intextwindow);
	if (second) intextwindow=true;
	menu.check(IDM_InTextWindow,intextwindow);

	graphicswindow = new GraphicsWindow("EuMathT - Euler Math Toolbox - Graphics",intextwindow);

	if (intextwindow) 
	{
		graphicswindow->hide();
		graphicswindow->timedsized(1);
	}

	savewithantialias=profile.readint("savewithantialias",savewithantialias);

	// get textwindow size
	textwindow.getsize(x,y,w,h);
	x=profile.readint(addres("xtext"),r.left+(r.right-r.left-1550)/2);
	y=profile.readint(addres("ytext"),r.top+(r.bottom-r.top-900)/2);
	w=profile.readint(addres("wtext"),700);
	h=profile.readint(addres("htext"),900);
	if (second) { x+=20; y+=20; }
	int tx=x,ty=y;
	if (w<600) w=600;
	if (x>r.right-w) { x=r.right-w; }
	if (x<r.left) { x=r.left; }
	if (x+w>r.right) { w=r.right-x; }
	if (h<400) h=400;
	if (y>r.bottom-h) y=r.bottom-h;
	if (y<r.top) { y=r.top; }
	if (y+h>r.bottom) h=r.bottom-y;
	textwindow.setsize(x,y,w,h);
	editx=x+50; edity=y+20; editw=w-60; edith=h-30;
	commentx=x+100; commenty=y+20; commentw=w-60; commenth=h-100;

	// get graphicswindow size
	graphicswindow->getsize(x,y,w,h);
	x=profile.readint(addres("xgraphics"),tx+750);
	y=profile.readint(addres("ygraphics"),ty+40);
	h=profile.readint(addres("hgraphics"),600);
	w=profile.readint(addres("wgraphics"),h);
	if (w<400) w=400;
	if (x>r.right-w) { x=r.right-w; }
	if (x<r.left) { x=r.left; }
	if (x+w>r.right) { w=r.right-x; }
	if (h<400) h=400;
	if (y>r.bottom-h) y=r.bottom-h;
	if (y<r.top) { y=r.top; }
	if (y+h>r.bottom) h=r.bottom-y;
	graphicswindow->setsize(x,y,w,h);
	helpx=x+50; helpy=y+20; helpw=w+50; helph=h-50;
	
	// initialize textwindow
	textwindow.clientmin(300,200);
	textwindow.accelerate(ID_ACC);

	// initialize colors
	char s[32];
	for (i=0; i<16; i++)
	{   
		sprintf(s,"color%d",i);
		mycolors.set(i,profile.readlong(s,(long)MyColor(i)));
	}
	for (i=0; i<6; i++)
	{   
		sprintf(s,"textcolor%d",i);
		*textcolors[i]=profile.readlong(s,(long)*textcolors[i]);
	}

	// read external editor settings
	externaleditor.copy(
		profile.read("externaleditor",(char *)externaleditor));
	externalparameters.copy("-jar \"");
	externalparameters.cat(getstartdir());
	externalparameters.cat("je.jar\"");
	externalparameters.copy(
		profile.read("externalparameters",(char *)externalparameters));
	externalfile.copy(
		profile.read("externalfile",(char *)externalfile));

	// read maxima and browser strings
	smaximacallstring.copy(profile.read("maximacallstring",""));
	smaximacalldir.copy(profile.read("maximacalldir",""));
	sbrowserstring.copy(profile.read("browserstring",""));
	sbrowserdir.copy(profile.read("browserdir",""));
	slatexbin.copy(profile.read("latexbin",""));
	slatexdir.copy(profile.read("latexdir",""));

	// read window sizes
	commentx=profile.readint(addres("commentx"),commentx);
	commenty=profile.readint(addres("commenty"),commenty);
	commentw=profile.readint(addres("commentw"),commentw);
	commenth=profile.readint(addres("commenth"),commenth);
	editx=profile.readint(addres("editx"),editx);
	edity=profile.readint(addres("edity"),edity);
	editw=profile.readint(addres("editw"),editw);
	edith=profile.readint(addres("edith"),edith);
	helpx=profile.readint(addres("helpx"),helpx);
	helpy=profile.readint(addres("helpy"),helpy);
	helpw=profile.readint(addres("helpw"),helpw);
	helph=profile.readint(addres("helph"),helph);

	respectfolding=profile.readint("respectfolding",respectfolding);
	noreformat=profile.readint("noreformat",noreformat);
	respectfoldinglatex=profile.readint("respectfoldinglatex",respectfoldinglatex);

	// read search string
	Search.copy(profile.read("search",""));

	// Initialize menu, and register menu callbacks
	menu.init();
	menu.add(IDM_Exit,doexit);
	menu.add(IDM_Restart,dorestart);
	menu.add(IDM_New,donew);
	menu.add(IDM_Open,doopen);
	menu.add(IDM_Save,dosavemenu);
	menu.add(IDM_Saveas,dosaveasmenu);
	menu.add(IDM_Comment,docomment);
	menu.add(IDM_UpdateComment,doupdatecomment);
	menu.add(IDM_Print,doprint);
	menu.add(IDM_CopyClipboard,docopy);
	menu.add(IDM_SetSizes,dosetsizes);
	menu.add(IDM_ExternalEditor,dosetupexternaleditor);
	menu.add(IDM_Codepage,docodepage);
	menu.add(IDM_Load,doload);
	menu.add(IDM_DeleteCommand,dodeletecommand);
	menu.add(IDM_InsertCommand,doinsertcommand);
	menu.add(IDM_UndoDelete,doundodelete);
	menu.add(IDM_CopyText,docopytext);
	menu.add(IDM_Cut,docuttext);
	menu.add(IDM_SelectAll,doselectall);
	menu.add(IDM_DeleteOutput,dodeleteoutput);
	menu.add(IDM_DeleteAllOutput,dodeletealloutput);
	menu.add(IDM_Edit,doedit);
	menu.add(IDM_ExternalEdit,doexternaledit);
	menu.add(IDM_SaveBitmap,dosavepng);
	menu.add(IDM_Postscript,dopostscript);
	menu.add(IDM_SVG,dosvg);
	menu.add(IDM_PasteCommands,dopastecommands);
	menu.add(IDM_PasteAsCommands,dopasteascommands);
	menu.add(IDM_CopyCommands,docopycommands);
	menu.add(IDM_CopyFormatted,docopyformatted);
	menu.add(IDM_SetFonts,dosetfonts);
	menu.add(IDM_SetColors,dosetcolors);
	menu.add(IDM_RunCommands,doruncommands);
	menu.add(IDM_UpdateAllComments,doupdatecomments);
	menu.add(IDM_ExportHTML,doexporthtml);
	menu.add(IDM_Markdown, doexportmarkdown);
	menu.add(IDM_InsertImage,doinsertimage);
	menu.add(IDM_Escape,doescape);
	menu.add(IDM_PreviousInput,dopreviousinput);
	menu.add(IDM_NextInput,donextinput);

	// help menu
	menu.add(IDM_OpenDocumentation,doopendocumentation);
	menu.add(IDM_MaximaReference,domaximareference);
	menu.add(IDM_OpenIntroduction,doopenintroduction);
	menu.add(IDM_EulerHelp, dobrowserhelp);
	menu.add(IDM_Reference, doreference);
	menu.add(IDM_EMT, doeulersite);
	menu.add(IDM_SearchEulerSite, dosearcheulersite);
	menu.add(IDM_About, doabout);

	menu.add(IDM_OpenOwn,doopenown);
	menu.add(IDM_SaveOwn,dosaveown);
	menu.add(IDM_ClearInput,doclearinput);
	menu.add(IDM_EditMaximaCallString,doeditmaximacallstring);
	menu.add(IDM_CopyWMF,docopywmf);
	menu.add(IDM_find,dofind);
	menu.add(IDM_findnext,dofindnext);
	menu.add(IDM_undo,doundo);
	menu.add(IDM_redo,doredo);
	menu.add(IDM_updateresults,updateresults);
	menu.add(IDM_maximamode,domaximamode);
	menu.add(IDM_maximamodedirect,domaximamodedirect);
	menu.add(IDM_ClearRecent,doclearrecent);
	menu.add(IDM_Crop,docrop);
	menu.add(IDM_SetBrowser,dosetbrowser);
	menu.add(IDM_PasteImage,dopasteimage);
	menu.add(IDM_ShowGraphics,doshowgraphics);
	menu.add(IDM_SetLatex,dosetlatex);
	menu.add(IDM_Size150,doenlarge);
	menu.add(IDM_BoldFont,doboldfont);
	menu.add(IDM_CreateZip,docreatezip);
	menu.add(IDM_FatterLines,dofatterlines);
	menu.add(IDM_overview, dooverview);
	menu.add(IDM_CreateEHTML,docreateehtml);
	menu.add(IDM_VersionLog,doversionlog);
	menu.add(IDM_ViewHTML,doviewhtml);
	menu.add(IDM_InTextWindow,dointextwindow);
	menu.add(IDM_ResetDefaults,doresetdefaults);
	menu.add(IDM_CheckNow,docheck);
	menu.add(IDM_generatepdf,dogeneratepdf);
	menu.add(IDM_SetAspect,dosetaspect);
	menu.add(IDM_DeleteNotebook,dodeletenotebook);
	menu.add(IDM_OpenHelpWindow,doeulerhelp);
	menu.add(IDM_spellcheck,dospellcheck);
	menu.add(IDM_addwords,doaddwords);
	menu.add(IDM_JoinLines,dojoinlines);
	menu.add(IDM_ClearCommand,doclearcommandline);
	menu.add(IDM_EulerDefault,doeulerdefault);
	menu.add(IDM_EulerBlackAndWhite,doeulerblackandwhite);
	menu.add(IDM_EulerWebFont,doeulerwebfont);
	menu.add(IDM_fullscreen,dofullscreen);
	menu.add(IDM_OpenSecond,doopensecond);

	menu.add(IDM_antialiasgraphics,doantialias);
	antialiasgraphics=profile.readint("antialiasgraphics",antialiasgraphics);
	setstyles();
	menu.check(IDM_antialiasgraphics,antialiasgraphics);
	
	CHECK(createbb);
	CHECK(scalelines);
	CHECK(askconfirmations);
	CHECK(imagesindirectory);
	CHECK(saveimages);
	CHECK(killo);
	CHECK(alwaysrestart);
	CHECK(startmaxima);
	CHECK(startyacas);
	CHECK(statushelp);
	CHECK(enablemaxima);
	CHECK(enableyacas);
	CHECK(brackets);
	CHECK(assignments);
	CHECK(spaces);
	CHECK(commas);
	CHECK(startinmaximamode);
	CHECK(usedirectmode);
	CHECK(allowoverwrite);
	CHECK(allowvaroverwrite);
	CHECK(alwaysrelax);
	CHECK(reportindex);
	CHECK(conditionvectors);
	CHECK(usecolors);
	CHECK(neverantialiasinsimg);
	CHECK(helpintitle);
	CHECK(allowsymbolicdp);
	CHECK(latexams);
	CHECK(latexlarger);
	CHECK(latexmagnify);
	CHECK(latexgreen);
	CHECK(latexcleanup);
	CHECK(latexsilent);
	CHECK(latextransparent);
	CHECK(fontlines);
	CHECK(largeimages);
	CHECK(askexec);
	CHECK(answermaxima);
	CHECK(checkforupdates);
	CHECK(utf);
	CHECK(disablelatex);
	CHECK(displaymathjaxaslatex);
	CHECK(generatexhtml);
	CHECK(savecompressedsvg);
	CHECK(foldallmultilines);
	CHECK(latexkeeplarge);
	CHECK(latexantialias);
	CHECK(linux);
	CHECK(english);
	CHECK(german);
	CHECK(insertsmaller);
	CHECK(systemscaling);
	CHECK(sharper);
	CHECK(logging);
	CHECK(python27)

	LOAD(exportlatexasmathjax);
	LOAD(htmlutf);
	LOAD(uselargeimagesforhtml);
	LOAD(openexportedhtml);
	LOAD(createsvg);
	LOAD(spellcheck);
	LOAD(CODE_PAGE);
	if (CODE_PAGE == -1) CODE_PAGE=GetACP();

	LOAD(generatelatexfileonly);
	LOAD(openexportedpdf);
	
	CHECK(fixlinelength);

	useutf = (GetACP() == 65001);
	
	textwindow.sized();

	menu.add(IDM_SplitCommand,dosplitcommand);
	menu.add(IDM_SplitLine,dosplitline);
	menu.add(IDM_QuickTips,doquicktips);
	menu.add(IDM_FunctionDefinition,dofunction);

	String logdir=getusereulerdir();
	if (logging)
	{
		logdir.cat("eulerlog.txt");
		initlog(logdir.text());
		flog("Logging started on %s",logdir.text());
		flog("EMT Version %s",version.text());
	}
	
	if (exists("/usr/bin") && exists("/usr/lib"))
		// try to fill out the correct values for plugins
	{
		if (exists("/usr/bin/firefox"))
		{
			if (sbrowserstring.length()==0) sbrowserstring.copy("/usr/bin/firefox");
			if (sbrowserdir.length()==0) sbrowserdir.copy("http://www.euler-math-toolbox.de");
		}
		if (exists("/usr/bin/maxima"))
		{
			if (smaximacallstring.length()==0) smaximacallstring.copy("/usr/bin/maxima");
		}
		if (exists("/usr/bin/latex"))
		{
			if (slatexbin.length()==0) slatexbin.copy("/usr/bin/");
		}
		if (externaleditor.length()==0 || externaleditor.equals("javaw.exe"))
		{
			externaleditor.copy("notepad.exe");
			externalparameters.copy("");
		}
		linux=1;
		systemscaling=0;
		menu.check(IDM_linux,1);
		helpintitle=1;
	}

	// Get hardspace character
	char s1[16]="\xC2\xA0";
	char *s2=fromutf(s1);
	hardspace=*s2;

	// Setup recent menu
	menu.remove(1,5000);
	getrecent();
	makerecent();

	if (!helpintitle && !onewindow)
	{
		SB=new StatusBar(textwindow);
	}

	// Initialize windows
	if (script) textwindow.sethidden(true);
	textwindow.init();
	if (script) graphicswindow->sethidden(true);
	graphicswindow->init();
	if (!script) textwindow.top();

	// Sleep(1000);

	profile.setfrozen(0);
	if (reset) 
	{
		doclearrecent();
		profile.writeint("textfont",tfontheight);
		profile.writeint("graphicslines",gscreenlines);
		profile.write("textfontname",TextFontName);
		profile.write("graphicsfontname",GraphicsFontName);
	}
	
	// Try to open euler.cfg in the current directory.
	// This may not be the start directory, if Euler starts
	// by double clicking an Euler file.
	// If not, switch the current directory to the start directory
	if (!exists("euler.cfg"))
	{	_chdir(dir);
		flog("Use configuration in %s",dir.text());
	}

	// load the online help
	String helpfile(getstartdir());
	helpfile.cat("\\help.txt");
	loadhelp(helpfile);
	helpfile.copy(getstartdir());
	helpfile.cat("\\overview.txt");
	loadhelp(helpfile,1);

	String maximahelpfile(getstartdir());
	maximahelpfile.cat("\\maxima.txt");
	loadmaximahelp(maximahelpfile);
	
	String maximastartup(getstartdir());
	maximastartup.cat("\\maximastartup.txt");
	loadmaximastartup(maximastartup);
	
	// look for a notebook to load in the parameter list
	if (argc==2)
	{   String name;
		name.copy(argv[1]);
		name.stripapostroph();
		if (name.testextension(".en"))
		{	wantload.copy(name);
			argv++; argc--;
		}
	}
	/*
	Buttons *BU=new Buttons();
	BU->addbutton(1,"Test 1");
	BU->addbutton(2,"Test 2");
	ToolBar *TB=new ToolBar(textwindow,101,*BU);
	textwindow.settoolbar(TB);
	*/
	
	// make_examples();
	// make_eulermenu();
	make_helpsections();

	if (firststart)
	{
		browse("tips.html");
	}

	// Check for Updates
	if (checkforupdates) newversionthread.start();

	// Make Maxima default paths if necessary
	if (smaximacallstring.length()==0 && smaximacalldir.length()==0)
		setmaximadefaults();

	flog("Start EMT process");

	// Start computation loop
	setwindowname();
	Sleep(100);
	computation.set(argc,argv);
	computation.start();
	program.loop();

	flog("End EMT process");

	// ****************** after loop **************************
	
	profile.setfrozen(GetKeyState(VK_SHIFT)<0);
	
	// Save window positions:
	if (fullscreen)	dofullscreen();

	if (second) goto dontsave;

	if (saveprofile) profile.openOutputFile(profiledir.text());

	WINDOWPLACEMENT plac;
	plac.length=sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(textwindow.handle(),&plac);
	if (!(plac.showCmd==SW_SHOWMAXIMIZED || plac.showCmd==SW_SHOWMINIMIZED))
	{	textwindow.getsize(x,y,w,h);
		profile.writeint(addres("xtext"),x);
		profile.writeint(addres("ytext"),y);
		profile.writeint(addres("wtext"),w);
		profile.writeint(addres("htext"),h);
	}
	profile.writeint(addres("textmax"),plac.showCmd==SW_SHOWMAXIMIZED);
	GetWindowPlacement(graphicswindow->handle(),&plac);
	if (!(plac.showCmd==SW_SHOWMAXIMIZED || plac.showCmd==SW_SHOWMINIMIZED))
	{	graphicswindow->getsize(x,y,w,h);
		profile.writeint(addres("xgraphics"),x);
		profile.writeint(addres("ygraphics"),y);
		profile.writeint(addres("wgraphics"),w);
		profile.writeint(addres("hgraphics"),h);
	}
	profile.writeint(addres("graphmax"),plac.showCmd==SW_SHOWMAXIMIZED);

	profile.write("search",Search.text());
	profile.write("printer",PrinterString.text());
	
	profile.writeint("savewithantialias",savewithantialias);

	SAVE(killo);
	SAVE(askconfirmations);
	SAVE(createbb);
#ifdef WIN64
	profile.writeint("stacksize64",stacksize);
	profile.writeint("graphicssize64",graphicssize);
#else
	SAVE(stacksize);
	SAVE(graphicssize);
#endif
	profile.writeint("cropsquare",savecropsquare);
	profile.writedouble("aspect",saveaspect);
	profile.writeint("boldfont",boldfont);
	profile.writeint("fatterlines",fatterlines);
	profile.writeint(addres("intextwindow"),intextwindow);
	profile.writeint("textfont",tfontheight);
	profile.writeint("graphicslines",gscreenlines);
	profile.write("textfontname",TextFontName);
	profile.write("graphicsfontname",GraphicsFontName);

	// save window sizes
	profile.writeint(addres("commentx"),commentx);
	profile.writeint(addres("commenty"),commenty);
	profile.writeint(addres("commentw"),commentw);
	profile.writeint(addres("commenth"),commenth);
	profile.writeint(addres("editx"),editx);
	profile.writeint(addres("edity"),edity);
	profile.writeint(addres("editw"),editw);
	profile.writeint(addres("edith"),edith);
	profile.writeint(addres("helpx"),helpx);
	profile.writeint(addres("helpy"),helpy);
	profile.writeint(addres("helpw"),helpw);
	profile.writeint(addres("helph"),helph);
	
	if (usecolors)
	{
		for (i=0; i<16; i++)
		{   
			sprintf(s,"color%d",i);
			profile.writelong(s,(long)(*savecolors.c(i)));
		}
	}
	for (i=0; i<6; i++)
	{   
		sprintf(s,"textcolor%d",i);
		profile.writelong(s,(long)(*textcolors[i]));
	}

	SAVE(scalelines);
	SAVE(saveimages);
	SAVE(imagesindirectory);
	profile.write("externaleditor",(char *)externaleditor);
	profile.write("externalparameters",(char *)externalparameters);
	profile.write("externalfile",(char *)externalfile);
	SAVE(statushelp);
	SAVE(alwaysrestart);
	SAVE(startmaxima);
	SAVE(startyacas);
	SAVE(enableyacas);
	SAVE(enablemaxima);
	SAVE(saveprofile);
	SAVE(brackets);
	SAVE(assignments);
	SAVE(spaces);
	SAVE(commas);
	SAVE(startinmaximamode);
	SAVE(usedirectmode);
	SAVE(allowoverwrite);
	SAVE(allowvaroverwrite);
	SAVE(alwaysrelax);
	SAVE(reportindex);
	SAVE(conditionvectors);
	SAVE(antialiasgraphics);
	SAVE(fixlinelength);
	SAVE(usecolors);
	SAVE(neverantialiasinsimg);
	SAVE(helpintitle);
	SAVE(allowsymbolicdp);
	SAVE(latexams);
	SAVE(latexlarger);
	SAVE(latexmagnify);
	SAVE(latexgreen);
	SAVE(latexcleanup);
	SAVE(latexsilent);
	SAVE(latextransparent);
	SAVE(fontlines);
	SAVE(largeimages);
	SAVE(askexec);
	SAVE(answermaxima);
	SAVE(checkforupdates);
	SAVE(htmlutf);
	SAVE(utf);
	SAVE(exportlatexasmathjax);
	SAVE(disablelatex);
	SAVE(displaymathjaxaslatex);
	SAVE(usecolors);
	SAVE(uselargeimagesforhtml);
	SAVE(openexportedhtml);
	SAVE(openexportedpdf);
	SAVE(generatelatexfileonly);
	SAVE(generatexhtml);
	SAVE(createsvg);
	SAVE(savecompressedsvg);
	SAVE(foldallmultilines);
	SAVE(latexkeeplarge);
	SAVE(latexantialias);
	SAVE(linux);
	SAVE(spellcheck);
	SAVE(english);
	SAVE(german);
	SAVE(insertsmaller);
	SAVE(systemscaling);
	SAVE(sharper);
	SAVE(logging);
	SAVE(python27);
	SAVE(CODE_PAGE);

	profile.write("maximacallstring",smaximacallstring);
	profile.write("maximacalldir",smaximacalldir);
	profile.write("browserstring",sbrowserstring);
	profile.write("browserdir",sbrowserdir);
	profile.write("latexbin",slatexbin);
	profile.write("latexdir",slatexdir);

	profile.writeint("respectfolding",respectfolding);
	profile.writeint("noreformat",noreformat);
	profile.writeint("respectfoldinglatex",respectfoldinglatex);

	profile.writeint("started",1);

	saverecent();	

	if (saveprofile)
	{
		profile.closeOutputFile();
		if (newuser) profile.remove();
	}

	flog("Configuration saved");

dontsave :
	
	closelibs();

#ifdef YACAS
	exit_yacas();
#endif
	end_maxima();
	execkill();

	flog("End logging");
	exitlog();

	while (printthread.active())
	{	if (!askconfirmations || Question("Stop print?","EULER")==Answers::yes) break;
	}

	return 0;
}

void myInvalidParameterHandler(const wchar_t * expression,
	const wchar_t * function, const wchar_t * file, unsigned int line, uintptr_t pReserved) 
{}

int winmain (int argc, char *argv[])
{
#ifndef CATCH
	return winmainhandled(__argc,__argv);
#endif;
	__try
	{
		_set_invalid_parameter_handler(myInvalidParameterHandler);
		return winmainhandled(__argc,__argv);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		exception=GetExceptionCode();
		exceptiontype=1;
		end_maxima();
		execkill();
		crash_message();
		exit(0);
	}
}

void crash_message ()
{
	dump("Sorry, Euler crashed (Code %x, %s)!\n"
		"\n"
		"Please help me to remove this bug and\n"
		"report the crash with sufficient details to\n"
		"\n"
		"rene.grothmann@gmail.com\n"
		"\n"
		"Thank you!",exception,exceptiontype==1?"in GUI":"in Code");
}
